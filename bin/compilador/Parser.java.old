
//----------------------------------------------------
// The following code was generated by CUP v0.10k
// Tue Jun 06 18:35:00 CEST 2006
//----------------------------------------------------

package compiler;

import java_cup.runtime.*;
import user.Log;
import java.util.ArrayList;
import java.util.HashMap;
import interprete.JMPascalVM;

/** CUP v0.10k generated parser.
  * @version Tue Jun 06 18:35:00 CEST 2006
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\177\000\002\002\004\000\002\071\002\000\002\026" +
    "\010\000\002\072\002\000\002\004\005\000\002\014\006" +
    "\000\002\015\004\000\002\015\002\000\002\013\005\000" +
    "\002\013\004\000\002\012\005\000\002\046\003\000\002" +
    "\046\003\000\002\047\003\000\002\050\005\000\002\050" +
    "\003\000\002\051\005\000\002\051\004\000\002\051\003" +
    "\000\002\053\005\000\002\053\003\000\002\052\003\000" +
    "\002\052\003\000\002\052\003\000\002\052\004\000\002" +
    "\052\005\000\002\021\004\000\002\021\002\000\002\032" +
    "\005\000\002\032\004\000\002\031\005\000\002\065\003" +
    "\000\002\065\003\000\002\065\003\000\002\066\005\000" +
    "\002\070\010\000\002\034\005\000\002\034\003\000\002" +
    "\073\002\000\002\067\006\000\002\057\005\000\002\057" +
    "\003\000\002\074\002\000\002\022\005\000\002\022\002" +
    "\000\002\025\005\000\002\025\004\000\002\020\005\000" +
    "\002\020\005\000\002\020\002\000\002\075\002\000\002" +
    "\016\012\000\002\076\002\000\002\077\002\000\002\017" +
    "\011\000\002\100\002\000\002\061\006\000\002\061\002" +
    "\000\002\063\005\000\002\063\003\000\002\062\004\000" +
    "\002\062\003\000\002\060\005\000\002\056\005\000\002" +
    "\056\003\000\002\024\005\000\002\030\005\000\002\030" +
    "\003\000\002\027\003\000\002\027\003\000\002\027\003" +
    "\000\002\027\003\000\002\027\002\000\002\101\002\000" +
    "\002\102\002\000\002\011\011\000\002\033\004\000\002" +
    "\033\002\000\002\003\004\000\002\045\005\000\002\103" +
    "\002\000\002\045\006\000\002\045\002\000\002\064\005" +
    "\000\002\064\003\000\002\005\003\000\002\005\003\000" +
    "\002\005\003\000\002\104\002\000\002\105\002\000\002" +
    "\010\010\000\002\006\012\000\002\023\003\000\002\023" +
    "\003\000\002\106\002\000\002\007\007\000\002\041\005" +
    "\000\002\041\003\000\002\042\005\000\002\042\004\000" +
    "\002\042\003\000\002\043\005\000\002\043\003\000\002" +
    "\044\003\000\002\044\003\000\002\044\004\000\002\044" +
    "\004\000\002\044\005\000\002\035\003\000\002\035\003" +
    "\000\002\035\003\000\002\035\003\000\002\035\003\000" +
    "\002\035\003\000\002\036\003\000\002\036\003\000\002" +
    "\036\003\000\002\037\003\000\002\037\003\000\002\037" +
    "\003\000\002\037\003\000\002\040\003\000\002\040\003" +
    "\000\002\055\003\000\002\055\002\000\002\054\005\000" +
    "\002\054\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\331\000\004\025\004\001\002\000\004\061\007\001" +
    "\002\000\004\002\006\001\002\000\004\002\001\001\002" +
    "\000\004\060\000\001\002\000\004\060\011\001\002\000" +
    "\016\006\ufffa\007\012\016\ufffa\024\ufffa\032\ufffa\034\ufffa" +
    "\001\002\000\004\061\321\001\002\000\004\006\ufffe\001" +
    "\002\000\004\057\175\001\002\000\014\006\uffe6\016\uffe6" +
    "\024\uffe6\032\016\034\uffe6\001\002\000\004\061\074\001" +
    "\002\000\012\006\uffd5\016\uffd5\024\uffd5\034\uffd7\001\002" +
    "\000\004\034\066\001\002\000\010\006\uffd0\016\uffd0\024" +
    "\uffd0\001\002\000\010\006\ufffc\016\026\024\025\001\002" +
    "\000\004\060\065\001\002\000\004\060\064\001\002\000" +
    "\004\061\056\001\002\000\004\061\027\001\002\000\006" +
    "\044\uffc8\054\uffca\001\002\000\004\044\051\001\002\000" +
    "\004\054\032\001\002\000\006\034\033\061\035\001\002" +
    "\000\004\061\035\001\002\000\006\055\uffc6\060\uffc6\001" +
    "\002\000\010\042\uffc1\044\uffc1\055\uffc1\001\002\000\006" +
    "\042\045\044\044\001\002\000\006\055\041\060\042\001" +
    "\002\000\006\055\uffc4\060\uffc4\001\002\000\006\044\uffc9" +
    "\060\uffc9\001\002\000\006\034\033\061\035\001\002\000" +
    "\006\055\uffc7\060\uffc7\001\002\000\004\061\047\001\002" +
    "\000\004\061\046\001\002\000\010\042\uffc2\044\uffc2\055" +
    "\uffc2\001\002\000\010\014\uffc3\055\uffc3\060\uffc3\001\002" +
    "\000\006\055\uffc5\060\uffc5\001\002\000\004\061\052\001" +
    "\002\000\004\060\053\001\002\000\016\006\uffcf\007\uffcf" +
    "\016\uffcf\024\uffcf\032\uffcf\034\uffcf\001\002\000\016\006" +
    "\ufffa\007\012\016\ufffa\024\ufffa\032\ufffa\034\ufffa\001\002" +
    "\000\004\060\uffce\001\002\000\006\054\uffcd\060\uffcd\001" +
    "\002\000\006\054\uffca\060\uffc8\001\002\000\004\060\061" +
    "\001\002\000\016\006\uffcc\007\uffcc\016\uffcc\024\uffcc\032" +
    "\uffcc\034\uffcc\001\002\000\016\006\ufffa\007\012\016\ufffa" +
    "\024\ufffa\032\ufffa\034\ufffa\001\002\000\004\060\uffcb\001" +
    "\002\000\010\006\uffd2\016\uffd2\024\uffd2\001\002\000\010" +
    "\006\uffd1\016\uffd1\024\uffd1\001\002\000\004\061\035\001" +
    "\002\000\012\006\uffd6\016\uffd6\024\uffd6\061\035\001\002" +
    "\000\004\060\071\001\002\000\012\006\uffd3\016\uffd3\024" +
    "\uffd3\061\uffd3\001\002\000\004\060\073\001\002\000\012" +
    "\006\uffd4\016\uffd4\024\uffd4\061\uffd4\001\002\000\004\045" +
    "\102\001\002\000\004\060\101\001\002\000\014\006\uffe7" +
    "\016\uffe7\024\uffe7\034\uffe7\061\074\001\002\000\004\060" +
    "\100\001\002\000\014\006\uffe5\016\uffe5\024\uffe5\034\uffe5" +
    "\061\uffe5\001\002\000\014\006\uffe4\016\uffe4\024\uffe4\034" +
    "\uffe4\061\uffe4\001\002\000\010\005\107\026\uffdb\054\110" +
    "\001\002\000\004\026\167\001\002\000\004\060\uffe2\001" +
    "\002\000\004\060\uffe0\001\002\000\004\060\uffe1\001\002" +
    "\000\004\040\114\001\002\000\004\061\035\001\002\000" +
    "\004\060\uffe3\001\002\000\006\042\045\055\113\001\002" +
    "\000\004\060\uffdf\001\002\000\020\021\120\046\125\053" +
    "\123\054\122\061\130\063\121\064\117\001\002\000\004" +
    "\041\164\001\002\000\012\023\155\036\162\046\156\053" +
    "\154\001\002\000\044\004\uffeb\010\uffeb\020\uffeb\023\uffeb" +
    "\036\uffeb\041\uffeb\043\uffeb\045\uffeb\046\uffeb\047\uffeb\050" +
    "\uffeb\051\uffeb\052\uffeb\053\uffeb\055\uffeb\056\uffeb\060\uffeb" +
    "\001\002\000\014\021\120\054\122\061\131\063\121\064" +
    "\117\001\002\000\044\004\uffec\010\uffec\020\uffec\023\uffec" +
    "\036\uffec\041\uffec\043\uffec\045\uffec\046\uffec\047\uffec\050" +
    "\uffec\051\uffec\052\uffec\053\uffec\055\uffec\056\uffec\060\uffec" +
    "\001\002\000\020\021\120\046\125\053\123\054\122\061" +
    "\131\063\121\064\117\001\002\000\014\021\uff87\054\uff87" +
    "\061\uff87\063\uff87\064\uff87\001\002\000\044\004\uffed\010" +
    "\uffed\020\uffed\023\uffed\036\uffed\041\uffed\043\uffed\045\uffed" +
    "\046\uffed\047\uffed\050\uffed\051\uffed\052\uffed\053\uffed\055" +
    "\uffed\056\uffed\060\uffed\001\002\000\014\021\uff88\054\uff88" +
    "\061\uff88\063\uff88\064\uff88\001\002\000\044\004\134\010" +
    "\137\020\133\023\uffef\036\uffef\041\uffef\043\uffef\045\uffef" +
    "\046\uffef\047\uffef\050\uffef\051\uffef\052\uffef\053\uffef\055" +
    "\uffef\056\135\060\uffef\001\002\000\014\021\120\054\122" +
    "\061\131\063\121\064\117\001\002\000\024\004\uffea\010" +
    "\uffea\020\uffea\023\uffea\036\uffea\041\uffdc\046\uffea\053\uffea" +
    "\056\uffea\001\002\000\044\004\uffea\010\uffea\020\uffea\023" +
    "\uffea\036\uffea\041\uffea\043\uffea\045\uffea\046\uffea\047\uffea" +
    "\050\uffea\051\uffea\052\uffea\053\uffea\055\uffea\056\uffea\060" +
    "\uffea\001\002\000\044\004\134\010\137\020\133\023\ufff0" +
    "\036\ufff0\041\ufff0\043\ufff0\045\ufff0\046\ufff0\047\ufff0\050" +
    "\ufff0\051\ufff0\052\ufff0\053\ufff0\055\ufff0\056\135\060\ufff0" +
    "\001\002\000\014\021\uff8b\054\uff8b\061\uff8b\063\uff8b\064" +
    "\uff8b\001\002\000\014\021\uff89\054\uff89\061\uff89\063\uff89" +
    "\064\uff89\001\002\000\014\021\uff8c\054\uff8c\061\uff8c\063" +
    "\uff8c\064\uff8c\001\002\000\014\021\120\054\122\061\131" +
    "\063\121\064\117\001\002\000\014\021\uff8a\054\uff8a\061" +
    "\uff8a\063\uff8a\064\uff8a\001\002\000\044\004\uffee\010\uffee" +
    "\020\uffee\023\uffee\036\uffee\041\uffee\043\uffee\045\uffee\046" +
    "\uffee\047\uffee\050\uffee\051\uffee\052\uffee\053\uffee\055\uffee" +
    "\056\uffee\060\uffee\001\002\000\030\023\155\043\ufff2\045" +
    "\ufff2\046\156\047\ufff2\050\ufff2\051\ufff2\052\ufff2\053\154" +
    "\055\ufff2\060\ufff2\001\002\000\020\043\150\045\144\047" +
    "\151\050\145\051\147\052\146\055\143\001\002\000\044" +
    "\004\uffe8\010\uffe8\020\uffe8\023\uffe8\036\uffe8\041\uffe8\043" +
    "\uffe8\045\uffe8\046\uffe8\047\uffe8\050\uffe8\051\uffe8\052\uffe8" +
    "\053\uffe8\055\uffe8\056\uffe8\060\uffe8\001\002\000\020\021" +
    "\uff91\046\uff91\053\uff91\054\uff91\061\uff91\063\uff91\064\uff91" +
    "\001\002\000\020\021\uff94\046\uff94\053\uff94\054\uff94\061" +
    "\uff94\063\uff94\064\uff94\001\002\000\020\021\uff92\046\uff92" +
    "\053\uff92\054\uff92\061\uff92\063\uff92\064\uff92\001\002\000" +
    "\020\021\uff93\046\uff93\053\uff93\054\uff93\061\uff93\063\uff93" +
    "\064\uff93\001\002\000\020\021\uff90\046\uff90\053\uff90\054" +
    "\uff90\061\uff90\063\uff90\064\uff90\001\002\000\020\021\uff95" +
    "\046\uff95\053\uff95\054\uff95\061\uff95\063\uff95\064\uff95\001" +
    "\002\000\020\021\120\046\125\053\123\054\122\061\131" +
    "\063\121\064\117\001\002\000\030\023\155\043\ufff3\045" +
    "\ufff3\046\156\047\ufff3\050\ufff3\051\ufff3\052\ufff3\053\154" +
    "\055\ufff3\060\ufff3\001\002\000\014\021\uff8e\054\uff8e\061" +
    "\uff8e\063\uff8e\064\uff8e\001\002\000\014\021\uff8d\054\uff8d" +
    "\061\uff8d\063\uff8d\064\uff8d\001\002\000\014\021\uff8f\054" +
    "\uff8f\061\uff8f\063\uff8f\064\uff8f\001\002\000\014\021\120" +
    "\054\122\061\131\063\121\064\117\001\002\000\044\004" +
    "\134\010\137\020\133\023\ufff1\036\ufff1\041\ufff1\043\ufff1" +
    "\045\ufff1\046\ufff1\047\ufff1\050\ufff1\051\ufff1\052\ufff1\053" +
    "\ufff1\055\ufff1\056\135\060\ufff1\001\002\000\044\004\uffe9" +
    "\010\uffe9\020\uffe9\023\uffe9\036\uffe9\041\uffe9\043\uffe9\045" +
    "\uffe9\046\uffe9\047\uffe9\050\uffe9\051\uffe9\052\uffe9\053\uffe9" +
    "\055\uffe9\056\uffe9\060\uffe9\001\002\000\020\021\120\046" +
    "\125\053\123\054\122\061\131\063\121\064\117\001\002" +
    "\000\012\023\155\041\uffdd\046\156\053\154\001\002\000" +
    "\004\022\165\001\002\000\004\061\166\001\002\000\004" +
    "\060\uffde\001\002\000\004\061\035\001\002\000\006\014" +
    "\173\060\172\001\002\000\006\014\uffd8\060\uffd8\001\002" +
    "\000\004\061\035\001\002\000\004\060\uffda\001\002\000" +
    "\006\014\uffd9\060\uffd9\001\002\000\004\002\uffff\001\002" +
    "\000\004\006\177\001\002\000\022\006\177\014\uffb9\015" +
    "\211\017\202\027\213\035\uffa9\060\uffb9\061\216\001\002" +
    "\000\006\057\ufffd\060\ufffd\001\002\000\012\013\uffbd\014" +
    "\uffbd\033\uffbd\060\uffbd\001\002\000\020\021\231\046\125" +
    "\053\123\054\232\061\237\063\233\064\226\001\002\000" +
    "\012\013\uffba\014\uffba\033\uffba\060\uffba\001\002\000\010" +
    "\014\uffbe\033\uffbe\060\uffbe\001\002\000\012\013\uffbc\014" +
    "\uffbc\033\uffbc\060\uffbc\001\002\000\012\013\uffbb\014\uffbb" +
    "\033\uffbb\060\uffbb\001\002\000\012\013\uffaa\014\uffaa\033" +
    "\uffaa\060\uffaa\001\002\000\012\013\uffac\014\uffac\033\uffac" +
    "\060\uffac\001\002\000\004\061\300\001\002\000\012\013" +
    "\uffab\014\uffab\033\uffab\060\uffab\001\002\000\022\006\uffa3" +
    "\015\uffa3\017\uffa3\027\uffa3\033\uffa3\035\uffa3\060\uffa3\061" +
    "\uffa3\001\002\000\006\014\272\060\271\001\002\000\004" +
    "\035\264\001\002\000\022\013\uffaf\014\uffaf\033\uffaf\037" +
    "\uff85\040\222\054\uffb1\057\224\060\uffaf\001\002\000\004" +
    "\054\256\001\002\000\004\037\254\001\002\000\064\004" +
    "\uff86\010\uff86\011\uff86\012\uff86\013\uff86\014\uff86\020\uff86" +
    "\023\uff86\030\uff86\031\uff86\033\uff86\037\uff86\041\uff86\042" +
    "\uff86\043\uff86\045\uff86\046\uff86\047\uff86\050\uff86\051\uff86" +
    "\052\uff86\053\uff86\055\uff86\056\uff86\060\uff86\001\002\000" +
    "\020\021\231\046\125\053\123\054\232\061\237\063\233" +
    "\064\226\001\002\000\012\013\uffb3\014\uffb3\033\uffb3\060" +
    "\uffb3\001\002\000\004\061\225\001\002\000\064\004\uff83" +
    "\010\uff83\011\uff83\012\uff83\013\uff83\014\uff83\020\uff83\023" +
    "\uff83\030\uff83\031\uff83\033\uff83\037\uff83\041\uff83\042\uff83" +
    "\043\uff83\045\uff83\046\uff83\047\uff83\050\uff83\051\uff83\052" +
    "\uff83\053\uff83\055\uff83\056\uff83\060\uff83\001\002\000\062" +
    "\004\uff99\010\uff99\011\uff99\012\uff99\013\uff99\014\uff99\020" +
    "\uff99\023\uff99\030\uff99\031\uff99\033\uff99\041\uff99\042\uff99" +
    "\043\uff99\045\uff99\046\uff99\047\uff99\050\uff99\051\uff99\052" +
    "\uff99\053\uff99\055\uff99\056\uff99\060\uff99\001\002\000\052" +
    "\011\uffa0\012\uffa0\013\uffa0\014\uffa0\023\155\030\uffa0\031" +
    "\uffa0\033\uffa0\041\uffa0\042\uffa0\043\uffa0\045\uffa0\046\156" +
    "\047\uffa0\050\uffa0\051\uffa0\052\uffa0\053\154\055\uffa0\060" +
    "\uffa0\001\002\000\062\004\134\010\137\011\uff9d\012\uff9d" +
    "\013\uff9d\014\uff9d\020\133\023\uff9d\030\uff9d\031\uff9d\033" +
    "\uff9d\041\uff9d\042\uff9d\043\uff9d\045\uff9d\046\uff9d\047\uff9d" +
    "\050\uff9d\051\uff9d\052\uff9d\053\uff9d\055\uff9d\056\135\060" +
    "\uff9d\001\002\000\014\021\231\054\232\061\237\063\233" +
    "\064\226\001\002\000\020\021\231\046\125\053\123\054" +
    "\232\061\237\063\233\064\226\001\002\000\062\004\uff9a" +
    "\010\uff9a\011\uff9a\012\uff9a\013\uff9a\014\uff9a\020\uff9a\023" +
    "\uff9a\030\uff9a\031\uff9a\033\uff9a\041\uff9a\042\uff9a\043\uff9a" +
    "\045\uff9a\046\uff9a\047\uff9a\050\uff9a\051\uff9a\052\uff9a\053" +
    "\uff9a\055\uff9a\056\uff9a\060\uff9a\001\002\000\020\041\245" +
    "\043\150\045\144\047\151\050\145\051\147\052\146\001" +
    "\002\000\062\004\uff9b\010\uff9b\011\uff9b\012\uff9b\013\uff9b" +
    "\014\uff9b\020\uff9b\023\uff9b\030\uff9b\031\uff9b\033\uff9b\041" +
    "\uff9b\042\uff9b\043\uff9b\045\uff9b\046\uff9b\047\uff9b\050\uff9b" +
    "\051\uff9b\052\uff9b\053\uff9b\055\uff9b\056\uff9b\060\uff9b\001" +
    "\002\000\014\021\231\054\232\061\237\063\233\064\226" +
    "\001\002\000\066\004\uff85\010\uff85\011\uff85\012\uff85\013" +
    "\uff85\014\uff85\020\uff85\023\uff85\030\uff85\031\uff85\033\uff85" +
    "\040\222\041\uff85\042\uff85\043\uff85\045\uff85\046\uff85\047" +
    "\uff85\050\uff85\051\uff85\052\uff85\053\uff85\055\uff85\056\uff85" +
    "\057\224\060\uff85\001\002\000\062\004\uff98\010\uff98\011" +
    "\uff98\012\uff98\013\uff98\014\uff98\020\uff98\023\uff98\030\uff98" +
    "\031\uff98\033\uff98\041\uff98\042\uff98\043\uff98\045\uff98\046" +
    "\uff98\047\uff98\050\uff98\051\uff98\052\uff98\053\uff98\055\uff98" +
    "\056\uff98\060\uff98\001\002\000\062\004\134\010\137\011" +
    "\uff9e\012\uff9e\013\uff9e\014\uff9e\020\133\023\uff9e\030\uff9e" +
    "\031\uff9e\033\uff9e\041\uff9e\042\uff9e\043\uff9e\045\uff9e\046" +
    "\uff9e\047\uff9e\050\uff9e\051\uff9e\052\uff9e\053\uff9e\055\uff9e" +
    "\056\135\060\uff9e\001\002\000\014\021\231\054\232\061" +
    "\237\063\233\064\226\001\002\000\062\004\uff9c\010\uff9c" +
    "\011\uff9c\012\uff9c\013\uff9c\014\uff9c\020\uff9c\023\uff9c\030" +
    "\uff9c\031\uff9c\033\uff9c\041\uff9c\042\uff9c\043\uff9c\045\uff9c" +
    "\046\uff9c\047\uff9c\050\uff9c\051\uff9c\052\uff9c\053\uff9c\055" +
    "\uff9c\056\uff9c\060\uff9c\001\002\000\020\021\231\046\125" +
    "\053\123\054\232\061\237\063\233\064\226\001\002\000" +
    "\064\004\uff84\010\uff84\011\uff84\012\uff84\013\uff84\014\uff84" +
    "\020\uff84\023\uff84\030\uff84\031\uff84\033\uff84\037\uff84\041" +
    "\uff84\042\uff84\043\uff84\045\uff84\046\uff84\047\uff84\050\uff84" +
    "\051\uff84\052\uff84\053\uff84\055\uff84\056\uff84\060\uff84\001" +
    "\002\000\052\011\uffa1\012\uffa1\013\uffa1\014\uffa1\023\155" +
    "\030\uffa1\031\uffa1\033\uffa1\041\uffa1\042\uffa1\043\uffa1\045" +
    "\uffa1\046\156\047\uffa1\050\uffa1\051\uffa1\052\uffa1\053\154" +
    "\055\uffa1\060\uffa1\001\002\000\014\021\231\054\232\061" +
    "\237\063\233\064\226\001\002\000\062\004\134\010\137" +
    "\011\uff9f\012\uff9f\013\uff9f\014\uff9f\020\133\023\uff9f\030" +
    "\uff9f\031\uff9f\033\uff9f\041\uff9f\042\uff9f\043\uff9f\045\uff9f" +
    "\046\uff9f\047\uff9f\050\uff9f\051\uff9f\052\uff9f\053\uff9f\055" +
    "\uff9f\056\135\060\uff9f\001\002\000\020\043\150\045\144" +
    "\047\151\050\145\051\147\052\146\055\252\001\002\000" +
    "\062\004\uff96\010\uff96\011\uff96\012\uff96\013\uff96\014\uff96" +
    "\020\uff96\023\uff96\030\uff96\031\uff96\033\uff96\041\uff96\042" +
    "\uff96\043\uff96\045\uff96\046\uff96\047\uff96\050\uff96\051\uff96" +
    "\052\uff96\053\uff96\055\uff96\056\uff96\060\uff96\001\002\000" +
    "\062\004\uff97\010\uff97\011\uff97\012\uff97\013\uff97\014\uff97" +
    "\020\uff97\023\uff97\030\uff97\031\uff97\033\uff97\041\uff97\042" +
    "\uff97\043\uff97\045\uff97\046\uff97\047\uff97\050\uff97\051\uff97" +
    "\052\uff97\053\uff97\055\uff97\056\uff97\060\uff97\001\002\000" +
    "\020\021\231\046\125\053\123\054\232\061\237\063\233" +
    "\064\226\001\002\000\026\013\uffb2\014\uffb2\033\uffb2\043" +
    "\150\045\144\047\151\050\145\051\147\052\146\060\uffb2" +
    "\001\002\000\020\021\231\046\125\053\123\054\232\061" +
    "\237\063\233\064\226\001\002\000\006\042\262\055\261" +
    "\001\002\000\022\042\uffad\043\150\045\144\047\151\050" +
    "\145\051\147\052\146\055\uffad\001\002\000\012\013\uffb0" +
    "\014\uffb0\033\uffb0\060\uffb0\001\002\000\020\021\231\046" +
    "\125\053\123\054\232\061\237\063\233\064\226\001\002" +
    "\000\022\042\uffae\043\150\045\144\047\151\050\145\051" +
    "\147\052\146\055\uffae\001\002\000\020\021\231\046\125" +
    "\053\123\054\232\061\237\063\233\064\226\001\002\000" +
    "\020\011\uffa8\043\150\045\144\047\151\050\145\051\147" +
    "\052\146\001\002\000\004\011\267\001\002\000\026\006" +
    "\177\013\uffb9\014\uffb9\015\211\017\202\027\213\033\uffb9" +
    "\035\uffa9\060\uffb9\061\216\001\002\000\012\013\uffa7\014" +
    "\uffa7\033\uffa7\060\uffa7\001\002\000\024\006\177\014\uffb9" +
    "\015\211\017\202\027\213\033\uffb9\035\uffa9\060\uffb9\061" +
    "\216\001\002\000\014\013\uffc0\014\uffc0\033\uffc0\057\uffc0" +
    "\060\uffc0\001\002\000\010\014\uffbf\033\uffbf\060\uffbf\001" +
    "\002\000\022\006\177\015\211\017\202\027\213\033\uffb9" +
    "\035\uffa9\060\uffb9\061\216\001\002\000\006\033\276\060" +
    "\271\001\002\000\020\021\231\046\125\053\123\054\232" +
    "\061\237\063\233\064\226\001\002\000\026\013\uffa2\014" +
    "\uffa2\033\uffa2\043\150\045\144\047\151\050\145\051\147" +
    "\052\146\060\uffa2\001\002\000\004\037\301\001\002\000" +
    "\020\021\231\046\125\053\123\054\232\061\237\063\233" +
    "\064\226\001\002\000\022\012\303\031\305\043\150\045" +
    "\144\047\151\050\145\051\147\052\146\001\002\000\020" +
    "\021\uffa4\046\uffa4\053\uffa4\054\uffa4\061\uffa4\063\uffa4\064" +
    "\uffa4\001\002\000\020\021\231\046\125\053\123\054\232" +
    "\061\237\063\233\064\226\001\002\000\020\021\uffa5\046" +
    "\uffa5\053\uffa5\054\uffa5\061\uffa5\063\uffa5\064\uffa5\001\002" +
    "\000\020\011\307\043\150\045\144\047\151\050\145\051" +
    "\147\052\146\001\002\000\026\006\177\013\uffb9\014\uffb9" +
    "\015\211\017\202\027\213\033\uffb9\035\uffa9\060\uffb9\061" +
    "\216\001\002\000\012\013\uffa6\014\uffa6\033\uffa6\060\uffa6" +
    "\001\002\000\020\030\312\043\150\045\144\047\151\050" +
    "\145\051\147\052\146\001\002\000\026\006\uffb8\013\uffb8" +
    "\014\uffb8\015\uffb8\017\uffb8\027\uffb8\033\uffb8\035\uffb8\060" +
    "\uffb8\061\uffb8\001\002\000\026\006\177\013\uffb9\014\uffb9" +
    "\015\211\017\202\027\213\033\uffb9\035\uffa9\060\uffb9\061" +
    "\216\001\002\000\012\013\uffb7\014\uffb7\033\uffb7\060\uffb7" +
    "\001\002\000\012\013\316\014\uffb4\033\uffb4\060\uffb4\001" +
    "\002\000\026\006\177\013\uffb9\014\uffb9\015\211\017\202" +
    "\027\213\033\uffb9\035\uffa9\060\uffb9\061\216\001\002\000" +
    "\012\013\uffb6\014\uffb6\033\uffb6\060\uffb6\001\002\000\012" +
    "\013\uffb5\014\uffb5\033\uffb5\060\uffb5\001\002\000\004\045" +
    "\327\001\002\000\016\006\ufffb\016\ufffb\024\ufffb\032\ufffb" +
    "\034\ufffb\061\321\001\002\000\004\060\324\001\002\000" +
    "\016\006\ufff8\016\ufff8\024\ufff8\032\ufff8\034\ufff8\061\ufff8" +
    "\001\002\000\004\060\326\001\002\000\016\006\ufff9\016" +
    "\ufff9\024\ufff9\032\ufff9\034\ufff9\061\ufff9\001\002\000\022" +
    "\021\120\046\125\053\123\054\122\061\131\062\333\063" +
    "\121\064\117\001\002\000\004\060\ufff7\001\002\000\020" +
    "\043\150\045\144\047\151\050\145\051\147\052\146\060" +
    "\ufff5\001\002\000\004\060\ufff6\001\002\000\004\060\ufff4" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\331\000\004\026\004\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\071\007\001\001" +
    "\000\002\001\001\000\010\004\013\014\012\015\014\001" +
    "\001\000\006\012\322\013\321\001\001\000\004\072\175" +
    "\001\001\000\002\001\001\000\004\021\016\001\001\000" +
    "\006\031\074\032\075\001\001\000\006\022\020\074\017" +
    "\001\001\000\002\001\001\000\004\020\021\001\001\000" +
    "\006\016\023\017\022\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\061" +
    "\027\100\030\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\056\035\060\037\062\033\063\036\001\001\000" +
    "\006\056\035\060\047\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\056\035\060\037\062\042" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\075\053\001" +
    "\001\000\010\004\054\014\012\015\014\001\001\000\002" +
    "\001\001\000\004\076\056\001\001\000\006\061\057\100" +
    "\030\001\001\000\002\001\001\000\004\077\061\001\001" +
    "\000\010\004\062\014\012\015\014\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\025\066" +
    "\056\035\060\067\001\001\000\006\056\035\060\071\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\031\076\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\065\110\066\103\067\104\070" +
    "\105\073\102\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\056\111\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\034\114\040\126\051\115\052" +
    "\123\053\125\001\001\000\002\001\001\000\004\036\156" +
    "\001\001\000\002\001\001\000\004\052\160\001\001\000" +
    "\002\001\001\000\014\040\126\050\141\051\140\052\123" +
    "\053\125\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\037\135\001\001\000\006\052\123" +
    "\053\131\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\037\135\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\052\137\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\036\156\001\001\000\004" +
    "\035\151\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\040\126\051\152\052" +
    "\123\053\125\001\001\000\004\036\156\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\052" +
    "\123\053\157\001\001\000\004\037\135\001\001\000\002" +
    "\001\001\000\012\040\126\051\162\052\123\053\125\001" +
    "\001\000\004\036\156\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\056\035\057\167\060" +
    "\170\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\056\035\060\173\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\024\177\001\001\000\026" +
    "\003\204\005\205\006\211\007\206\010\207\011\200\024" +
    "\202\027\203\030\213\104\214\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\040\235\041\310\042\226\043" +
    "\227\044\234\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\106\273\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\045\222\054\220\055\217\103\216\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\040" +
    "\235\041\233\042\226\043\227\044\234\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\036\246\001\001\000\004\037\241\001\001" +
    "\000\004\044\252\001\001\000\014\040\235\041\250\042" +
    "\226\043\227\044\234\001\001\000\002\001\001\000\004" +
    "\035\243\001\001\000\002\001\001\000\006\043\240\044" +
    "\234\001\001\000\006\054\220\055\237\001\001\000\002" +
    "\001\001\000\004\037\241\001\001\000\004\044\242\001" +
    "\001\000\002\001\001\000\012\040\235\042\245\043\227" +
    "\044\234\001\001\000\002\001\001\000\004\036\246\001" +
    "\001\000\006\043\247\044\234\001\001\000\004\037\241" +
    "\001\001\000\004\035\243\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\040\235\041\254\042\226\043\227" +
    "\044\234\001\001\000\004\035\243\001\001\000\016\040" +
    "\235\041\257\042\226\043\227\044\234\064\256\001\001" +
    "\000\002\001\001\000\004\035\243\001\001\000\002\001" +
    "\001\000\014\040\235\041\262\042\226\043\227\044\234" +
    "\001\001\000\004\035\243\001\001\000\014\040\235\041" +
    "\264\042\226\043\227\044\234\001\001\000\006\035\243" +
    "\105\265\001\001\000\002\001\001\000\024\003\204\005" +
    "\205\006\211\007\206\010\207\011\200\024\202\027\267" +
    "\104\214\001\001\000\002\001\001\000\024\003\204\005" +
    "\205\006\211\007\206\010\207\011\200\024\202\027\272" +
    "\104\214\001\001\000\002\001\001\000\002\001\001\000" +
    "\026\003\204\005\205\006\211\007\206\010\207\011\200" +
    "\024\202\027\203\030\274\104\214\001\001\000\002\001" +
    "\001\000\014\040\235\041\276\042\226\043\227\044\234" +
    "\001\001\000\004\035\243\001\001\000\002\001\001\000" +
    "\014\040\235\041\301\042\226\043\227\044\234\001\001" +
    "\000\006\023\303\035\243\001\001\000\002\001\001\000" +
    "\014\040\235\041\305\042\226\043\227\044\234\001\001" +
    "\000\002\001\001\000\004\035\243\001\001\000\024\003" +
    "\204\005\205\006\211\007\206\010\207\011\200\024\202" +
    "\027\307\104\214\001\001\000\002\001\001\000\004\035" +
    "\243\001\001\000\004\101\312\001\001\000\024\003\204" +
    "\005\205\006\211\007\206\010\207\011\200\024\202\027" +
    "\313\104\214\001\001\000\004\102\314\001\001\000\004" +
    "\033\316\001\001\000\024\003\204\005\205\006\211\007" +
    "\206\010\207\011\200\024\202\027\317\104\214\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\012\324\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\020\040\126\046" +
    "\327\047\331\050\330\051\140\052\123\053\125\001\001" +
    "\000\002\001\001\000\004\035\151\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {


	action_obj.inicializa(tabla, log, fileName);
	

    }



	public TablaSimbolos tabla = null; 
	public Log log= null;
	
	private String fileName = null;
	
	public Parser (TablaSimbolos tabla, Log log, String fileName){
		this();
		this.tabla = tabla;
		this.log = log;
		this.fileName = fileName;
	}

	public void syntax_error(Symbol tokenActual){
//	   System.out.println("syntax");
       log.anadirLog("\nError sintáctico: <token= "
                + tokenActual.sym + ", texto=\""
				+ (String) tokenActual.value + "\"> <fila= "
				+ tokenActual.left + ", columna= "
				+ tokenActual.right
				+ ">........ Intentando recuperarse..... ");
	}

	public void unrecovered_syntax_error(Symbol tokenActual) throws ErrorSintacticoException{
//	    System.out.println("syntax_fatal");
	    String cadena="<token= "
                + tokenActual.sym + ", texto=\""
				+ (String) tokenActual.value + "\"> <fila= "
				+ tokenActual.left + ", columna= "
				+ tokenActual.right
				+ ">.... Irrecuperable => Traducción Abortada";
        throw new ErrorSintacticoException(cadena);
	}
	
	public void report_fatal_error(String msg, Object info) throws ErrorSintacticoException{
//	    System.out.println("report fatal");
	    Symbol tokenActual = (Symbol) info;
	    String cadena="<token= "
                + tokenActual.sym + ", texto=\""
				+ (String) tokenActual.value + "\"> <fila= "
				+ tokenActual.left + ", columna= "
				+ tokenActual.right
				+ ">.... Irrecuperable => Traducción Abortada";
        throw new ErrorSintacticoException(cadena);
	}
	
	public void report_error(String msg, Object info){
//	   System.out.println("report");
	   Symbol tokenActual = (Symbol) info;
       log.anadirLog("\nError sintáctico: <token= "
                + tokenActual.sym + ", texto=\""
				+ (String) tokenActual.value + "\"> <fila= "
				+ tokenActual.left + ", columna= "
				+ tokenActual.right
				+ ">........ Intentando recuperarse..... ");
	}


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {



	private TablaSimbolos tabla = null; 
	private Log log= null;
	private HashMap hash = null;
	private Generador generador = null;
	
	private String separador = System.getProperty("line.separator");
	private ArrayList colaInstrucciones = null;
	
	public int queAnalizo=-1; // Marca si lo que se está analizando es un registro para no meter los campos como variables
	public static final int REGISTRO = 0 ;
	public static final int PARAMETROS = 1 ;
	public static final int VARIABLES = 2 ;
	public static final int LLAMADA = 3 ;
	
	public boolean valorDevuelto = true; /**** Luego debe ser false ***/
	
	public void inicializa(TablaSimbolos tabla, Log log, String fileName){
		this.tabla = tabla;
		this.log = log;
		hash = new HashMap();
		generador = new Generador(fileName);
		colaInstrucciones = new ArrayList();
	}
					   
	public String generaCargaDir(ObjetoVariable objeto){
  	  String cadena = null;
	// System.out.println("queAnalizo = " + queAnalizo);
	  if (queAnalizo != LLAMADA){
	     if (objeto.getNivel()==tabla.getGlobal())
	        generador.gCDirGlobal(objeto.getDireccion());
	     else if (objeto.getNivel()==tabla.getActivo())
	  	         generador.gCDirLocal(objeto.getDireccion());
		      else
			     generador.gCDirInterm(objeto.getDireccion(),2);
	     try{
	        ObjetoParametro parametro = (ObjetoParametro) objeto;
	        if (parametro.isReferencia()){
	           generador.gCIndValor(JMPascalVM.TAMDIR);
	        }
	     }catch(ClassCastException cce){
//	        System.out.println("Hay una excepción de no parámetro");
	     }
	  }
	  else{
        if (objeto.getNivel()==tabla.getGlobal()){
  	       cadena = "CDIRGLOBAL " + objeto.getDireccion();
  	    }
        else{
           if (objeto.getNivel()==tabla.getActivo()){
	  	      cadena="CDIRLOCAL " + objeto.getDireccion();
	  	   }
	       else{
	  	      cadena="CDIRINTERM " + objeto.getDireccion();
	  	   }
		   try{
              ObjetoParametro parametro = (ObjetoParametro) objeto;
	  	      if (parametro.isReferencia()){
                 cadena +=separador + "\nCINDVALOR " + JMPascalVM.TAMDIR;
              }
           }catch(ClassCastException e){
           }
	  	}
	  }
      return cadena;
	}		

	public String generaCargaDirArray(ObjetoVariable objeto){
  	  String cadena = null;
	// System.out.println("queAnalizo = " + queAnalizo);

	  ObjetoTipoTabla tipo = (ObjetoTipoTabla) objeto.getTipo();
	  if (queAnalizo != LLAMADA){
	  	 if (objeto.getNivel()==tabla.getGlobal())
	        generador.gCDirGlobal(objeto.getDireccion());
	     else if (objeto.getNivel()==tabla.getActivo())
	  	         generador.gCDirLocal(objeto.getDireccion());
		      else
			     generador.gCDirInterm(objeto.getDireccion(),2);
	     try{
	        ObjetoParametro parametro = (ObjetoParametro) objeto;
	        if (parametro.isReferencia()){
	           generador.gCIndValor(JMPascalVM.TAMDIR);
	        }
	     }catch(ClassCastException cce){
//	        System.out.println("Hay una excepción de no parámetro");
	     }
	     generador.gDElemento(tipo.getInicio(),tipo.getTipo().getSize());
	  }
	  else{
	     if (objeto.getNivel()==tabla.getGlobal())
    	    cadena = "CDIRGLOBAL " + objeto.getDireccion();
	     else{
	       if (objeto.getNivel()==tabla.getActivo())
	  	      cadena = "CDIRLOCAL " + objeto.getDireccion();
//	  	      cadena = "CDIRLOCAL " + parametro.getDireccion();
		   else
		      cadena = "CDIRINTERM " + objeto.getDireccion();
//		      cadena = "CDIRINTERM " + parametro.getDireccion();
		   try{
              ObjetoParametro parametro = (ObjetoParametro) objeto;
	  	      if (parametro.isReferencia()){
                 cadena +=separador + "CINDVALOR " + JMPascalVM.TAMDIR;
              }
           }catch(ClassCastException e){
           }
		 }
	     cadena+=separador + "DELEMENTO " + tipo.getInicio()  + " " + tipo.getTipo().getSize();
	  }
      return cadena;
	}		

	public String generaCargaDirRegistro(ObjetoVariable objeto, ObjetoCampo campo){
	  String cadena = null;
	// System.out.println("queAnalizo = " + queAnalizo);
	
	  if (queAnalizo != LLAMADA){
	     if (objeto.getNivel()==tabla.getGlobal())
	             generador.gCDirGlobal(objeto.getDireccion());
	     else if (objeto.getNivel()==tabla.getActivo())
	  	         generador.gCDirLocal(objeto.getDireccion());
		      else
			     generador.gCDirInterm(objeto.getDireccion(),2);
	     try{
	        ObjetoParametro parametro = (ObjetoParametro) objeto;
	        if (parametro.isReferencia()){
	           generador.gCIndValor(JMPascalVM.TAMDIR);
	        }
	     }catch(ClassCastException cce){
//	        System.out.println("Hay una excepción de no parámetro");
	     }
	  	 generador.gDCampo(campo.getDireccion());
	  }
	  else{
	     if (objeto.getNivel()==tabla.getGlobal())
  	        cadena = "CDIRGLOBAL " + objeto.getDireccion();
	     else{
	        if (objeto.getNivel()==tabla.getActivo())
	  	       cadena = "CDIRLOCAL " + objeto.getDireccion();
		    else
		  	   cadena = "CDIRINTERM " + objeto.getDireccion();
		  	try{
               ObjetoParametro parametro = (ObjetoParametro) objeto;
	  	       if (parametro.isReferencia()){
                  cadena +=separador + "CINDVALOR " + JMPascalVM.TAMDIR;
               }
            }catch(ClassCastException e){
            }
		 }
	     cadena+=separador + "DCAMPO " + campo.getDireccion();
	  }
      return cadena;
	}		


  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // selector ::= sPUNTO pID 
            {
              AnalisisSelector RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
		  					RESULT = new AnalisisSelector(AnalisisSelector.RECORD, id);
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(42/*selector*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // selector ::= sCORAPER expresion sCORCIE 
            {
              AnalisisSelector RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
							// Aquí se controlan todos los valores para ello hacemos uso del la instrucción JMPascal LIMITACION a b C (INICIO, FIN Y OPERANDOS DELANTE)
							/* Hay que comprobar que la expresión es entera */
							if (exp.getTipo()!=this.tabla.getInteger())
								throw new ErrorSemanticoException("Los índices siempre deben ser expresiones con valor entero (Línea: " + expleft + " Columna: " + expright + ")");
							if (this.queAnalizo==LLAMADA){
								ArrayList cola = exp.getCola();
								for(int j=0; j<cola.size();j++){
								   ArrayList instruccion = (ArrayList) cola.get(j);
								   this.generador.anyadeCodigo((String) instruccion.get(1));
								}
							}
							RESULT = new AnalisisSelector(AnalisisSelector.ARRAY);
						
              CUP$Parser$result = new java_cup.runtime.Symbol(42/*selector*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // restoNombre ::= 
            {
              AnalisisSelector RESULT = null;
		
				  			RESULT = null;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(43/*restoNombre*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // restoNombre ::= selector 
            {
              AnalisisSelector RESULT = null;
		int selleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int selright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisSelector sel = (AnalisisSelector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = sel;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(43/*restoNombre*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // signo ::= sMENOS 
            {
              Character RESULT = null;
		
							RESULT = new Character('-');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(30/*signo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // signo ::= sMAS 
            {
              Character RESULT = null;
		
							RESULT = null;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(30/*signo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // opMult ::= prAND 
            {
              Character RESULT = null;
		
							RESULT = new Character('&');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(29/*opMult*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // opMult ::= prDIV 
            {
              Character RESULT = null;
		
							RESULT = new Character('/');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(29/*opMult*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // opMult ::= prMOD 
            {
              Character RESULT = null;
		
							RESULT = new Character('%');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(29/*opMult*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // opMult ::= sPOR 
            {
              Character RESULT = null;
		
							RESULT = new Character('*');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(29/*opMult*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // opAdt ::= prOR 
            {
              Character RESULT = null;
		
							RESULT = new Character('|');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(28/*opAdt*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // opAdt ::= sMENOS 
            {
              Character RESULT = null;
		
							RESULT = new Character('-');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(28/*opAdt*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // opAdt ::= sMAS 
            {
              Character RESULT = null;
		
							RESULT = new Character('+');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(28/*opAdt*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // opRel ::= sDISTINTO 
            {
              Character RESULT = null;
		
							RESULT = new Character('!');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(27/*opRel*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // opRel ::= sIGUAL 
            {
              Character RESULT = null;
		
							RESULT = new Character('=');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(27/*opRel*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // opRel ::= sMENORIGU 
            {
              Character RESULT = null;
		
							RESULT = new Character('m');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(27/*opRel*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // opRel ::= sMENOR 
            {
              Character RESULT = null;
		
							RESULT = new Character('<');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(27/*opRel*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // opRel ::= sMAYORIGU 
            {
              Character RESULT = null;
		
							RESULT = new Character('M');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(27/*opRel*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // opRel ::= sMAYOR 
            {
              Character RESULT = null;
		
							RESULT = new Character('>');
						
              CUP$Parser$result = new java_cup.runtime.Symbol(27/*opRel*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // factor ::= sPARAPER expresion sPARCIE 
            {
              AnalisisExp RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
				  			// Se permite que una expresión de sólo variable vaya entre paréntesis
				  			RESULT = exp;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(34/*factor*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // factor ::= prNOT factor 
            {
              AnalisisExp RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			if (exp.getTipo()==this.tabla.getBoolean()){
				  				exp.setEsVariable(false);
				  				RESULT = exp;
				  				if (this.queAnalizo!=LLAMADA)
				  					this.generador.gNegacion();
				  				else{
									ArrayList cola = new ArrayList(2);
									cola.add(null);
									cola.add("NEGACION");
					   	        	RESULT.encolaInstruccion(cola);
					   	    	}
				  			}
				  			else
				  				throw new ErrorSemanticoException("No coinciden los tipos (Línea "+
				  					expleft + " Columna: " + expright + ")");
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(34/*factor*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // factor ::= pID restoNombre 
            {
              AnalisisExp RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int selleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int selright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisSelector sel = (AnalisisSelector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			Object objeto = null;
				  			if (this.queAnalizo!=LLAMADA){
					  			if ((objeto = this.tabla.buscarGlobal(id.toLowerCase()))!=null){
					  				if (sel == null){ // Caso de una variable de tipo simple o constante según el lenguaje ( no se permiten funciones )
					  					try{
					  						ObjetoCte constante = (ObjetoCte) objeto;
											//******hay que hacer el try catch => Aunque las constantes no pueden declararse con otros tipos		
											try{
												ObjetoCteEntera cteEntera = (ObjetoCteEntera) constante;
												RESULT=new AnalisisExp(this.tabla.getInteger(),false);
												this.generador.gCConstante(cteEntera.getValor()); /**** Comprobar si es esto o carga de valor de una constante */
			  								}catch(ClassCastException ex){
												try{
													ObjetoCteReal cteReal = (ObjetoCteReal) constante;
													RESULT=new AnalisisExp(this.tabla.getReal(),false);
													this.generador.gCConstanteReal(cteReal.getValor()); /**** Comprobar si es esto o carga de valor de una constante */
				  								}catch(ClassCastException ex1){
													try{
														ObjetoCteLogica cteLogica = (ObjetoCteLogica) constante;
														RESULT=new AnalisisExp(this.tabla.getBoolean(),false);
														this.generador.gCConstante((cteLogica.getValor())?1:0); /**** Comprobar si es esto o carga de valor de una constante */
					  								}catch(ClassCastException ex2){
														throw new ErrorSemanticoException("La constante "+
							  								id + " no es de un tipo valido "+
							  								" (Línea: " + idleft + " Columna: "+
					  										idright + ")");
					  									
					  								}
				  								}
			  								}
					  					}catch(ClassCastException e){
					  						try{
						  						ObjetoVariable variable = (ObjetoVariable) objeto;
						  						this.generaCargaDir(variable);
												this.generador.gCIndValor(variable.getTipo().getSize());
// **** CAMBIO PARA PODER PASAR MATRICES COMO PARÁMETROS
/*												try{
													ObjetoTipoPredefinido tipo = (ObjetoTipoPredefinido) variable.getTipo();
													if (tipo == this.tabla.getInteger()){
														RESULT=new AnalisisExp(this.tabla.getInteger(),true);
													}
													else if (tipo == this.tabla.getReal()){
															RESULT=new AnalisisExp(this.tabla.getReal(),true);
														 }
													 	 else if (tipo == this.tabla.getBoolean()){
																  RESULT=new AnalisisExp(this.tabla.getBoolean(),true);
															  }
												}catch(ClassCastException ex){
												// ***** AQUI
//****INICIO DEL CAMBIO PARA VER QUE SE PUEDEN ASIGNACIONES  DE NO PRIMITIVOS
												    try{
														RESULT = new AnalisisExp(variable.getTipo(),true);
//****FIN DEL CAMBIO PARA VER QUE SE PUEDEN ASIGNACIONES  DE NO PRIMITIVOS
												    }catch (ClassCastException e){
													   throw new ErrorSemanticoException("Las variable "+
					  								                id + " no es de un tipo predefinido, falta el selector "+
					  												" (Línea: " + idleft + " Columna: "+
					  												idright + ")");
					  							    }
												} */
// **** FIN CAMBIO PARA PODER PASAR MATRICES COMO PARÁMETROS
												RESULT=new AnalisisExp(variable.getTipo(),true);
					  						}catch(ClassCastException ex1){
					  							throw new ErrorSemanticoException("Las expresiones deben"+
					  								" estar formadas por variables, constantes definidas"+
					  								" y constantes númericas (Línea: " + idleft + " Columna: "+
					  								idright + ")");
						  					}
					  					}
					  				}
					  				else{ // Caso de una variable de tipo registro o array
					  					/* Puede ser array o registro */
					  					try{
						  					ObjetoVariable variable = (ObjetoVariable) objeto;
						  					switch(sel.getTipo()){
						  						case AnalisisSelector.ARRAY:
													try{
														ObjetoTipoTabla tipo = (ObjetoTipoTabla) variable.getTipo();
														//**** Creo que aquí habría que generar la carga y la limitacion
														this.generador.gLimitacion(tipo.getInicio(),tipo.getFin(),0);
														this.generaCargaDirArray(variable);
														this.generador.gCIndValor(tipo.getTipo().getSize());
														if (tipo.getTipo() == this.tabla.getInteger()){
															RESULT=new AnalisisExp(this.tabla.getInteger(),true);
														}
														else if (tipo.getTipo() == this.tabla.getReal()){
																RESULT=new AnalisisExp(this.tabla.getReal(),true);
															 }
															 else if (tipo.getTipo() == this.tabla.getBoolean()){
																	  RESULT=new AnalisisExp(this.tabla.getBoolean(),true);
																  }
						  								break;
													}catch(ClassCastException e){
														throw new ErrorSemanticoException("La variable "+
															id+" no es de tipo array (Línea: "+idleft+" Columna: " +
																idright + ")");
													}
						  						case AnalisisSelector.RECORD:
													try{
														ObjetoTipoRegistro registro = (ObjetoTipoRegistro) variable.getTipo();
														ObjetoCampo campo = null;
														if ((campo = registro.getCampo(sel.getSelector()))==null)
															throw new ErrorSemanticoException("El registro "+
																id+" no contiene ningun campo con el nombre " +
																sel.getSelector() + " (Línea: "+idleft+" Columna: " +
																idright + ")");
														else{ 
															this.generaCargaDirRegistro(variable,campo);
															this.generador.gCIndValor(campo.getTipo().getSize());
															if (campo.getTipo() == this.tabla.getInteger())
																RESULT=new AnalisisExp(this.tabla.getInteger(),true);
															else if (campo.getTipo() == this.tabla.getReal())
																	RESULT=new AnalisisExp(this.tabla.getReal(),true);
														 		 else if (campo.getTipo() == this.tabla.getBoolean())
																		  RESULT=new AnalisisExp(this.tabla.getBoolean(),true);
														}
						  								break;
													}catch(ClassCastException e){
														throw new ErrorSemanticoException("La variable "+
															id+" no es de tipo registro (Línea: "+idleft+" Columna: " +
																idright + ")");
													}
						  					}
						  				}catch(ClassCastException e){
						  					throw new ErrorSemanticoException("El identificador "+id+
						  						"no se corresponde con una variable (Línea: "+
						  						idleft+" Columna: "+idright+")");
						  				}
					  				}// else => record o array
					  			} // if existe identificador
					  			else
					  				throw new ErrorSemanticoException("El identificador " + 
					  					id+ " no está declarado (Línea: "+idleft + 
					  					" Columna: " + idright + ")");
					  		}
					  		else{
					  			ArrayList cola=new ArrayList(2);
					  			if ((objeto = this.tabla.buscarGlobal(id.toLowerCase()))!=null){
					  				if (sel == null){ // Caso de una variable de tipo simple o constante según el lenguaje ( no se permiten funciones )
					  					try{
					  						ObjetoCte constante = (ObjetoCte) objeto;
											//******hay que hacer el try catch => Aunque las constantes no pueden declararse con otros tipos		
											try{
												ObjetoCteEntera cteEntera = (ObjetoCteEntera) constante;
												RESULT=new AnalisisExp(this.tabla.getInteger(),false);
									   	        cola.add(null);
									   	        cola.add("CCONSTANTE " + cteEntera.getValor());
									   	        RESULT.encolaInstruccion(cola);
			  								}catch(ClassCastException ex){
												try{
													ObjetoCteReal cteReal = (ObjetoCteReal) constante;
													RESULT=new AnalisisExp(this.tabla.getReal(),false);
										   	        cola.add(null);
										   	        cola.add("CCONSTANTEREAL " + cteReal.getValor());
										   	        RESULT.encolaInstruccion(cola);
				  								}catch(ClassCastException ex1){
													try{
														ObjetoCteLogica cteLogica = (ObjetoCteLogica) constante;
														RESULT=new AnalisisExp(this.tabla.getBoolean(),false);
											   	        cola.add(null);
											   	        cola.add("CCONSTANTE " + ((cteLogica.getValor())?1:0));
											   	        RESULT.encolaInstruccion(cola);
					  								}catch(ClassCastException ex2){
													    try{
														   ObjetoCteLiteral cteLiteral = (ObjetoCteLiteral) constante;
														   RESULT=new AnalisisExp(this.tabla.getString(),false);
											   	           cola.add(null);
											   	           cola.add("CLITERAL " + cteLiteral.getValor().length() + " " + cteLiteral.getNumEtiqueta());
											   	           RESULT.encolaInstruccion(cola);
					  								    }catch(ClassCastException ex3){
														   throw new ErrorSemanticoException("La constante "+
							  								   id + " no es de un tipo valido "+
							  								   " (Línea: " + idleft + " Columna: "+
					  										   idright + ")");
					  								    }
					  								}
				  								}
			  								}
					  					}catch(ClassCastException e){
					  						try{
						  						ObjetoVariable variable = (ObjetoVariable) objeto;
// ******* CAMBIOS PARA PODER PASAR MATRICES COMO PARÁMETROS
/*												try{
													ObjetoTipoPredefinido tipo = (ObjetoTipoPredefinido) variable.getTipo();
													if (tipo == this.tabla.getInteger()){
														RESULT=new AnalisisExp(this.tabla.getInteger(),true);
// *											   	        cola.add(new Boolean(true));
											   	        cola.add(this.generaCargaDir(variable));
											   	        RESULT.encolaInstruccion(cola);
											   	        cola.clear();
											   	        cola.add(new Boolean(false));
											   	        cola.add("CINDVALOR "+variable.getTipo().getSize());
											   	        RESULT.encolaInstruccion(cola); * /
													}
													else if (tipo == this.tabla.getReal()){
															RESULT=new AnalisisExp(this.tabla.getReal(),true);
// *												   	        cola.add(new Boolean(true));
												   	        cola.add(this.generaCargaDir(variable));
												   	        RESULT.encolaInstruccion(cola);
												   	        cola.clear();
												   	        cola.add(new Boolean(false));
												   	        cola.add("CINDVALOR "+variable.getTipo().getSize());
												   	        RESULT.encolaInstruccion(cola); * /
														 }
													 	 else if (tipo == this.tabla.getBoolean()){
																  RESULT=new AnalisisExp(this.tabla.getBoolean(),true);
// *													   	          cola.add(new Boolean(true));
													   	          cola.add(this.generaCargaDir(variable));
													   	          RESULT.encolaInstruccion(cola);
													   	          cola.clear();
													   	          cola.add(new Boolean(false));
													   	          cola.add("CINDVALOR "+variable.getTipo().getSize());
													   	          RESULT.encolaInstruccion(cola); * /
															  } 
													cola.add(new Boolean(true));
										   	        cola.add(this.generaCargaDir(variable));
										   	        RESULT.encolaInstruccion(cola);
										   	        cola.clear();
										   	        cola.add(new Boolean(false));
										   	        cola.add("CINDVALOR "+variable.getTipo().getSize());
										   	        RESULT.encolaInstruccion(cola);
												}catch(ClassCastException ex){
													throw new ErrorSemanticoException("Las variable "+
					  								id + " no es de un tipo predefinido, falta el selector "+
					  								" (Línea: " + idleft + " Columna: "+
					  								idright + ")");
												} */
// ******* FIN CAMBIOS PARA PODER PASAR MATRICES COMO PARÁMETROS
											   RESULT=new AnalisisExp(variable.getTipo(),true);
											   cola.add(new Boolean(true));
										   	   cola.add(this.generaCargaDir(variable));
										   	   RESULT.encolaInstruccion(cola);
										   	   cola.clear();
										   	   cola.add(new Boolean(false));
										   	   cola.add("CINDVALOR "+variable.getTipo().getSize());
										   	   RESULT.encolaInstruccion(cola);
					  						}catch(ClassCastException ex1){
					  							throw new ErrorSemanticoException("Las expresiones deben"+
					  								" estar formadas por variables, constantes ** definidas"+
					  								" y constantes númericas (Línea: " + idleft + " Columna: "+
					  								idright + ")");
						  					}
					  					}
					  				}
					  				else{ // Caso de una variable de tipo registro o array
					  					/* Puede ser array o registro */
					  					try{
						  					ObjetoVariable variable = (ObjetoVariable) objeto;
						  					switch(sel.getTipo()){
						  						case AnalisisSelector.ARRAY:
													try{
														ObjetoTipoTabla tipo = (ObjetoTipoTabla) variable.getTipo();
														//**** Creo que aquí habría que generar la carga y la limitacion
														// BUSCAR AQUI ****
														if (tipo.getTipo() == this.tabla.getInteger()){
															RESULT=new AnalisisExp(this.tabla.getInteger(),true);
/*												   	        cola.add(new Boolean(true));
												   	        cola.add("LIMITACION " + tipo.getInicio() + " " + tipo.getFin() + " 0");
												   	        RESULT.encolaInstruccion(cola);
												   	        cola.clear();
												   	        cola.add(new Boolean(true));
												   	        cola.add(this.generaCargaDirArray(variable));
												   	        RESULT.encolaInstruccion(cola);
												   	        cola.clear();
												   	        cola.add(new Boolean(false));
												   	        cola.add("CINDVALOR "+variable.getTipo().getSize());
												   	        RESULT.encolaInstruccion(cola); */
/*
															RESULT.encolaInstruccion("LIMITACION " + tipo.getInicio() + " " + tipo.getFin() + " 0");
															RESULT.encolaInstruccion(this.generaCargaDirArray(variable));
															RESULT.encolaInstruccion("CINDVALOR " + tipo.getTipo().getSize()); */
														}
														else if (tipo.getTipo() == this.tabla.getReal()){
																RESULT=new AnalisisExp(this.tabla.getReal(),true);
/*																RESULT.encolaInstruccion("LIMITACION " + tipo.getInicio() + " " + tipo.getFin() + " 0");
																RESULT.encolaInstruccion(this.generaCargaDirArray(variable));
																RESULT.encolaInstruccion("CINDVALOR " + tipo.getTipo().getSize()); */
															 }
															 else if (tipo.getTipo() == this.tabla.getBoolean()){
																	  RESULT=new AnalisisExp(this.tabla.getBoolean(),true);
/*																	  RESULT.encolaInstruccion("LIMITACION " + tipo.getInicio() + " " + tipo.getFin() + " 0");
																	  RESULT.encolaInstruccion(this.generaCargaDirArray(variable));
																	  RESULT.encolaInstruccion("CINDVALOR " + tipo.getTipo().getSize()); */
																  }
											   	        cola.add(new Boolean(true));
											   	        cola.add("LIMITACION " + tipo.getInicio() + " " + tipo.getFin() + " 0");
											   	        RESULT.encolaInstruccion(cola);
											   	        cola.clear();
											   	        cola.add(new Boolean(true));
											   	        cola.add(this.generaCargaDirArray(variable));
											   	                  // System.out.println("El que no lanza la excepción en 2303");
											   	        RESULT.encolaInstruccion(cola);
											   	        cola.clear();
											   	        cola.add(new Boolean(false));
											   	        // ******2305
											   	        // ***** HABría 	que meter el try catch
											   	        cola.add("CINDVALOR "+((ObjetoTipoTabla)variable.getTipo()).getTipo().getSize());
											   	        RESULT.encolaInstruccion(cola);
						  								break;
													}catch(ClassCastException e){
														throw new ErrorSemanticoException("La variable "+
															id+" no es de tipo array (Línea: "+idleft+" Columna: " +
																idright + ")");
													}
						  						case AnalisisSelector.RECORD:
													try{
														ObjetoTipoRegistro registro = (ObjetoTipoRegistro) variable.getTipo();
														ObjetoCampo campo = null;
														if ((campo = registro.getCampo(sel.getSelector()))==null)
															throw new ErrorSemanticoException("El registro "+
																id+" no contiene ningun campo con el nombre " +
																sel.getSelector() + " (Línea: "+idleft+" Columna: " +
																idright + ")");
														else{ 
															if (campo.getTipo() == this.tabla.getInteger())
																RESULT=new AnalisisExp(this.tabla.getInteger(),true);
															else if (campo.getTipo() == this.tabla.getReal())
																	RESULT=new AnalisisExp(this.tabla.getReal(),true);
														 		 else if (campo.getTipo() == this.tabla.getBoolean())
																		  RESULT=new AnalisisExp(this.tabla.getBoolean(),true);
															cola.add(new Boolean(true));
															cola.add(this.generaCargaDirRegistro(variable,campo));
															RESULT.encolaInstruccion(cola);
															cola.clear();
															cola.add(new Boolean(false));
															cola.add("CINDVALOR " + campo.getTipo().getSize());
															RESULT.encolaInstruccion(cola);
/*															RESULT.encolaInstruccion(this.generaCargaDirRegistro(variable,campo));
															RESULT.encolaInstruccion("CINDVALOR " + campo.getTipo().getSize()); */
														}
						  								break;
													}catch(ClassCastException e){
														throw new ErrorSemanticoException("La variable "+
															id+" no es de tipo registro (Línea: "+idleft+" Columna: " +
																idright + ")");
													}
						  					}
						  				}catch(ClassCastException e){
						  					throw new ErrorSemanticoException("El identificador "+id+
						  						"no se corresponde con una variable (Línea: "+
						  						idleft+" Columna: "+idright+")");
						  				}
					  				}// else => record o array
					  			} // if existe identificador
					  			else
					  				throw new ErrorSemanticoException("El identificador " + 
					  					id+ " no está declarado (Línea: "+idleft + 
					  					" Columna: " + idright + ")");
					  		}
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(34/*factor*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // factor ::= pCteReal 
            {
              AnalisisExp RESULT = null;
		int cteleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int cteright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		Float cte = (Float)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = new AnalisisExp(this.tabla.getReal(),false);
							if (this.queAnalizo!=LLAMADA)
								this.generador.gCConstanteReal(cte.floatValue());
							else{
								ArrayList cola = new ArrayList(2);
								cola.add(null);
								cola.add("CCONSTANTEREAL "+cte.floatValue());
					   	        RESULT.encolaInstruccion(cola);
					   	    }
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(34/*factor*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // factor ::= pCteEntera 
            {
              AnalisisExp RESULT = null;
		int cteleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int cteright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		Integer cte = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = new AnalisisExp(this.tabla.getInteger(),false);
							if (this.queAnalizo!=LLAMADA)
								this.generador.gCConstante(cte.intValue());
							else{
								ArrayList cola = new ArrayList(2);
								cola.add(null);
								cola.add("CCONSTANTE "+cte.intValue());
					   	        RESULT.encolaInstruccion(cola);
					   	    }
						
              CUP$Parser$result = new java_cup.runtime.Symbol(34/*factor*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // termino ::= factor 
            {
              AnalisisExp RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT = exp;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(33/*termino*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // termino ::= termino opMult factor 
            {
              AnalisisExp RESULT = null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExp exp1 = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character op = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp2 = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (this.queAnalizo!=LLAMADA){
								switch (op.charValue()){
									case '&':
										if (exp1.getTipo() == this.tabla.getBoolean() && exp2.getTipo() == this.tabla.getBoolean()){
										   RESULT = new AnalisisExp(this.tabla.getBoolean(),false);
										   this.generador.gConjuncion();
										}
										else
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										break;
									case '*':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
												this.generador.gProducto();
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											  		 RESULT = new AnalisisExp(this.tabla.getReal(),false);
											  		 this.generador.gProductoReal();
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   this.generador.gAReal(JMPascalVM.TAMREAL);
														   this.generador.gProductoReal();
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
											  		   		   this.generador.gAReal(0);
													  		   this.generador.gProductoReal();
												   			}
										break;
									case '/':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
												this.generador.gDivision();
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											         RESULT = new AnalisisExp(this.tabla.getReal(),false);  
											  		 this.generador.gDivisionReal();
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   this.generador.gAReal(JMPascalVM.TAMREAL);
														   this.generador.gDivisionReal();
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
											    	           this.generador.gAReal(0);
													  		   this.generador.gDivisionReal();
												   			}
										break;
									case '%':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
												this.generador.gModulo();
											 }	
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											  		 RESULT = new AnalisisExp(this.tabla.getReal(),false);
											  		 this.generador.gModuloReal();
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   this.generador.gAReal(JMPascalVM.TAMREAL);
														   this.generador.gModuloReal();
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
											    	           this.generador.gAReal(0);
													  		   this.generador.gModuloReal();
												   			}
										break;
								}
							}
							else{
								ArrayList cola = new ArrayList(2);
								cola.add(null);
								switch (op.charValue()){
									case '&':
										if (exp1.getTipo() == this.tabla.getBoolean() && exp2.getTipo() == this.tabla.getBoolean()){
										   RESULT = new AnalisisExp(this.tabla.getBoolean(),false);
										   RESULT.anyadeCola(exp1.getCola());
										   RESULT.anyadeCola(exp2.getCola());
										   cola.add("CONJUNCION");
									   	   RESULT.encolaInstruccion(cola);
										}
										else
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										break;
									case '*':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
											    RESULT.anyadeCola(exp1.getCola());
											    RESULT.anyadeCola(exp2.getCola());
											    cola.add("PRODUCTO");
 										   	    RESULT.encolaInstruccion(cola);
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											  		 RESULT = new AnalisisExp(this.tabla.getReal(),false);
												     RESULT.anyadeCola(exp1.getCola());
												     RESULT.anyadeCola(exp2.getCola());
											   	     cola.add("PRODUCTOREAL");
											   	     RESULT.encolaInstruccion(cola);
											   	     
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   RESULT.anyadeCola(exp1.getCola());
														   RESULT.anyadeCola(exp2.getCola());
													   	   cola.add("AREAL " + JMPascalVM.TAMREAL);
													   	   RESULT.encolaInstruccion(cola);
													   	   cola.clear();
													   	   cola.add(null);
													   	   cola.add("PRODUCTOREAL");
													   	   RESULT.encolaInstruccion(cola);
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
															   RESULT.anyadeCola(exp1.getCola());
															   RESULT.anyadeCola(exp2.getCola());
														   	   cola.add("AREAL 0");
														   	   RESULT.encolaInstruccion(cola);
														   	   cola.clear();
														   	   cola.add(null);
														   	   cola.add("PRODUCTOREAL");
														   	   RESULT.encolaInstruccion(cola);
												   			}
										break;
									case '/':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
											    RESULT.anyadeCola(exp1.getCola());
											    RESULT.anyadeCola(exp2.getCola());
										   	    cola.add("DIVISION");
										   	    RESULT.encolaInstruccion(cola);
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											         RESULT = new AnalisisExp(this.tabla.getReal(),false);  
												     RESULT.anyadeCola(exp1.getCola());
												     RESULT.anyadeCola(exp2.getCola());
											   	     cola.add("DIVISIONREAL");
											   	     RESULT.encolaInstruccion(cola);
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   RESULT.anyadeCola(exp1.getCola());
														   RESULT.anyadeCola(exp2.getCola());
												   	       cola.add("AREAL " + JMPascalVM.TAMREAL);
												   	       RESULT.encolaInstruccion(cola);
												   	       cola.clear();
												   	       cola.add(null);
												   	       cola.add("DIVISIONREAL");
												   	       RESULT.encolaInstruccion(cola);
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
															   RESULT.anyadeCola(exp1.getCola());
															   RESULT.anyadeCola(exp2.getCola());
												   	       	   cola.add("AREAL 0");
												   	           RESULT.encolaInstruccion(cola);
												   	           cola.clear();
												   	           cola.add(null);
												   	           cola.add("DIVISIONREAL");
												   	           RESULT.encolaInstruccion(cola);
												   			}
										break;
									case '%':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
											    RESULT.anyadeCola(exp1.getCola());
											    RESULT.anyadeCola(exp2.getCola());
											    cola.add("MODULO");
										   	    RESULT.encolaInstruccion(cola);
											 }	
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											  		 RESULT = new AnalisisExp(this.tabla.getReal(),false);
												     RESULT.anyadeCola(exp1.getCola());
												     RESULT.anyadeCola(exp2.getCola());
											   	     cola.add("MODULOREAL");
											   	     RESULT.encolaInstruccion(cola);
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
													       RESULT.anyadeCola(exp1.getCola());
													       RESULT.anyadeCola(exp2.getCola());
												   	       cola.add("AREAL " + JMPascalVM.TAMREAL);
												   	       RESULT.encolaInstruccion(cola);
												   	       cola.clear();
												   	       cola.add(null);
												   	       cola.add("MODULOREAL");
												   	       RESULT.encolaInstruccion(cola);
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														       RESULT.anyadeCola(exp1.getCola());
														       RESULT.anyadeCola(exp2.getCola());
													   	       cola.add("AREAL 0");
													   	       RESULT.encolaInstruccion(cola);
													   	       cola.clear();
													   	       cola.add(null);
													   	       cola.add("MODULOREAL");
													   	       RESULT.encolaInstruccion(cola);
												   			}
										break;
								}
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(33/*termino*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // exprSimple ::= termino 
            {
              AnalisisExp RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
		  			   			RESULT = exp;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(32/*exprSimple*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // exprSimple ::= signo termino 
            {
              AnalisisExp RESULT = null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character s = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
		  			   			RESULT = exp;
					  			if (s!=null)
				  					RESULT.setEsVariable(false);
				  					if (exp.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
											  +sleft+" Columna: "+sright+")");
									else
						  				if (this.queAnalizo!=LLAMADA){
					  			      		this.generador.gNegativo();
							  			}
							  			else{
							  				ArrayList cola = new ArrayList(2);
							  				cola.add(null);
							  				cola.add("NEGATIVO");
									   	    RESULT.encolaInstruccion(cola);
					  					}
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(32/*exprSimple*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // exprSimple ::= exprSimple opAdt termino 
            {
              AnalisisExp RESULT = null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExp exp1 = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character op = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp2 = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (this.queAnalizo!=LLAMADA){
								switch (op.charValue()){
									case '|':
										if (exp1.getTipo() == this.tabla.getBoolean() && exp2.getTipo() == this.tabla.getBoolean()){
										   RESULT = new AnalisisExp(this.tabla.getBoolean(),false);
										   this.generador.gDisyuncion();
										}
										else
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										break;
									case '+':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
												this.generador.gSuma();
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											  		 RESULT = new AnalisisExp(this.tabla.getReal(),false);
											  		 this.generador.gSumaReal();
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   this.generador.gAReal(JMPascalVM.TAMREAL);
														   this.generador.gSumaReal();
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
											  		   		   this.generador.gAReal(0);
													  		   this.generador.gSumaReal();
												   			}
										break;
									case '-':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
												this.generador.gResta();
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											         RESULT = new AnalisisExp(this.tabla.getReal(),false);  
											  		 this.generador.gRestaReal();
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   this.generador.gAReal(JMPascalVM.TAMREAL);
														   this.generador.gRestaReal();
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
											    	           this.generador.gAReal(0);
													  		   this.generador.gRestaReal();
												   			}
										break;
								}
							}
							else{
 							    ArrayList cola = new ArrayList(2);
 							    cola.add(null);
								switch (op.charValue()){
									case '|':
										if (exp1.getTipo() == this.tabla.getBoolean() && exp2.getTipo() == this.tabla.getBoolean()){
										   RESULT = new AnalisisExp(this.tabla.getBoolean(),false);
										   RESULT.anyadeCola(exp1.getCola());
										   RESULT.anyadeCola(exp2.getCola());
										   cola.add("DISYUNCION");
	 									   RESULT.encolaInstruccion(cola);
										}
										else
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
									break;
									case '+':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
											    RESULT.anyadeCola(exp1.getCola());
											    RESULT.anyadeCola(exp2.getCola());
											    cola.add("SUMA");
											    RESULT.encolaInstruccion(cola);
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											  		 RESULT = new AnalisisExp(this.tabla.getReal(),false);
										   			 RESULT.anyadeCola(exp1.getCola());
										   			 RESULT.anyadeCola(exp2.getCola());
										   			 cola.add("SUMAREAL");
												     RESULT.encolaInstruccion(cola);
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   RESULT.anyadeCola(exp1.getCola());
														   RESULT.anyadeCola(exp2.getCola());
														   cola.add("AREAL " + JMPascalVM.TAMREAL);
													       RESULT.encolaInstruccion(cola);
														   cola.clear();
														   cola.add(null);
													   	   cola.add("SUMAREAL");
													       RESULT.encolaInstruccion(cola);
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
															   RESULT.anyadeCola(exp1.getCola());
															   RESULT.anyadeCola(exp2.getCola());
														   	   cola.add("AREAL 0");
														       RESULT.encolaInstruccion(cola);
															   cola.clear();
															   cola.add(null);
														   	   cola.add("SUMAREAL");
														   	   RESULT.encolaInstruccion(cola);
												   			}
										break;
									case '-':
										if (exp1.getTipo() == this.tabla.getBoolean() || exp2.getTipo() == this.tabla.getBoolean())
											throw new ErrorSemanticoException("No coinciden los tipos (Línea:"
												+opleft+" Columna: "+opright+")");
										else if (exp1.getTipo() == this.tabla.getInteger() && exp2.getTipo() == this.tabla.getInteger()){
												RESULT = new AnalisisExp(this.tabla.getInteger(),false);
											    RESULT.anyadeCola(exp1.getCola());
											    RESULT.anyadeCola(exp2.getCola());
										   	    cola.add("RESTA");
										   	    RESULT.encolaInstruccion(cola);
											 }
											 else if (exp1.getTipo() == this.tabla.getReal() && exp2.getTipo() == this.tabla.getReal()){
											         RESULT = new AnalisisExp(this.tabla.getReal(),false);  
												     RESULT.anyadeCola(exp1.getCola());
												     RESULT.anyadeCola(exp2.getCola());
											   	     cola.add("RESTAREAL");
											   	     RESULT.encolaInstruccion(cola);
											  	  }
										   		  else if (exp1.getTipo() == this.tabla.getInteger()){
										   		  		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
														   RESULT.anyadeCola(exp1.getCola());
														   RESULT.anyadeCola(exp2.getCola());
													   	   cola.add("AREAL "+JMPascalVM.TAMREAL);
												   	       RESULT.encolaInstruccion(cola);
													   	   cola.clear();
													   	   cola.add(null);
													   	   cola.add("RESTAREAL");
												   	       RESULT.encolaInstruccion(cola);
											  		   }
											  		   else if (exp2.getTipo() == this.tabla.getInteger()){
											  		   		   RESULT = new AnalisisExp(this.tabla.getReal(),false);
															   RESULT.anyadeCola(exp1.getCola());
															   RESULT.anyadeCola(exp2.getCola());
														   	   cola.add("AREAL 0");
														   	   RESULT.encolaInstruccion(cola);
														   	   cola.clear();
														   	   cola.add(null);
														   	   cola.add("RESTAREAL");
														   	   RESULT.encolaInstruccion(cola);
												   			}
										break;
								}
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(32/*exprSimple*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // expresion ::= exprSimple 
            {
              AnalisisExp RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT = exp;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(31/*expresion*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // expresion ::= expresion opRel exprSimple 
            {
              AnalisisExp RESULT = null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExp exp1 = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character op = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp2 = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
								RESULT=new AnalisisExp(this.tabla.getBoolean(),false);
								RESULT.anyadeCola(exp1.getCola());
								RESULT.anyadeCola(exp2.getCola());
								if (this.queAnalizo!=LLAMADA){
									if (exp1.getTipo()!=this.tabla.getReal() && exp2.getTipo()!=this.tabla.getReal()){
										switch(op.charValue()){
											case '=':
												this.generador.gIgual();
												break;
											case '<':
												this.generador.gMenor();
												break;
											case '>':
												this.generador.gMayor();
												break;
											case 'M':
												this.generador.gMayorIgu();
												break;
											case 'm':
												this.generador.gMenorIgu();
												break;
											case '!':
												this.generador.gDistinto();
												break;
										}
									}
									else{
										if (exp1.getTipo()==this.tabla.getInteger() || exp1.getTipo()==this.tabla.getBoolean())
										    this.generador.gAReal(JMPascalVM.TAMREAL);
										if (exp2.getTipo()==this.tabla.getInteger() || exp2.getTipo()==this.tabla.getBoolean())
										    this.generador.gAReal(0);
										switch(op.charValue()){
											case '=':
												this.generador.gIgualReal();
												break;
											case '<':
												this.generador.gMenorReal();
												break;
											case '>':
												this.generador.gMayorReal();
												break;
											case 'M':
												this.generador.gMayorIguReal();
												break;
											case 'm':
												this.generador.gMenorIguReal();
												break;
											case '!':
												this.generador.gDistintoReal();
												break;
										}
									}
								}
								else{
									ArrayList cola=new ArrayList(2);
									cola.add(null);
									if (exp1.getTipo()!=this.tabla.getReal() && exp2.getTipo()!=this.tabla.getReal()){
										switch(op.charValue()){
											case '=':
											    cola.add("IGUAL");
												break;
											case '<':
											    cola.add("MENOR");
												break;
											case '>':
											    cola.add("MAYOR");
												break;
											case 'M':
											    cola.add("MAYORIGU");
												break;
											case 'm':
											    cola.add("MENOR");
												break;
											case '!':
											    cola.add("MENORIGU");
												break;
										}
										RESULT.encolaInstruccion(cola);
									}
									else{
										if (exp1.getTipo()==this.tabla.getInteger() || exp1.getTipo()==this.tabla.getBoolean())
										    cola.add("AREAL " + JMPascalVM.TAMREAL);
										if (exp2.getTipo()==this.tabla.getInteger() || exp2.getTipo()==this.tabla.getBoolean())
										    cola.add("AREAL 0");
										RESULT.encolaInstruccion(cola);
										cola.clear();
										cola.add(null);
										switch(op.charValue()){
											case '=':
												cola.add("IGUALREAL");
												break;
											case '<':
												cola.add("MENORREAL");
												break;
											case '>':
												cola.add("MAYORREAL");
												break;
											case 'M':
												cola.add("MAYORIGUREAL");
												break;
											case 'm':
												cola.add("MENORIGUREAL");
												break;
											case '!':
												cola.add("DISTINTOREAL");
												break;
										}
										RESULT.encolaInstruccion(cola);
									}
								}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(31/*expresion*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // bucleREPEAT ::= prREPEAT NT$13 sentencias prUNTIL expresion 
            {
              Object RESULT = null;
              // propagate RESULT from NT$13
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (exp.getTipo() != this.tabla.getBoolean())
								throw new ErrorSemanticoException("Las expresiones de las condiciones deben ser de tipo lógico (Línea: " + expleft + " Columna: " + expright + ")");
							else
								this.generador.gBifCond(this.tabla.getNumCondicionalActual());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(5/*bucleREPEAT*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // NT$13 ::= 
            {
              Object RESULT = null;

							this.generador.gEtqCondicional(this.tabla.actualizaNumCondicional());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(68/*NT$13*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // direccion ::= prDOWNTO 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(17/*direccion*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // direccion ::= prTO 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(17/*direccion*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // bucleFOR ::= prFOR pID sASIGNACION expresion direccion expresion prDO sentencia 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int dirleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int dirright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object dir = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;

              CUP$Parser$result = new java_cup.runtime.Symbol(4/*bucleFOR*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // bucleWHILE ::= NT$11 prWHILE expresion NT$12 prDO sentencia 
            {
              Object RESULT = null;
              // propagate RESULT from NT$11
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
              // propagate RESULT from NT$12
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
							this.generador.gBifIncond(this.tabla.getNumIncondicionalActual());
							this.generador.gEtqCondicional(this.tabla.getNumCondicionalActual());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(6/*bucleWHILE*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // NT$12 ::= 
            {
              Object RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;

							if (exp.getTipo() != this.tabla.getBoolean())
								throw new ErrorSemanticoException("Las expresiones de las condiciones deben ser de tipo lógico (Línea: " + expleft + " Columna: " + expright + ")");
							else
								this.generador.gBifCond(this.tabla.actualizaNumCondicional());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(67/*NT$12*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // NT$11 ::= 
            {
              Object RESULT = null;

							this.generador.gEtqCondicional(this.tabla.actualizaNumIncondicional());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(66/*NT$11*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // bucle ::= bucleREPEAT 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(3/*bucle*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // bucle ::= bucleFOR 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(3/*bucle*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // bucle ::= bucleWHILE 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(3/*bucle*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // paramLlamada ::= expresion 
            {
              ArrayList RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT=new ArrayList();
				  			RESULT.add(exp);
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(50/*paramLlamada*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // paramLlamada ::= paramLlamada sCOMA expresion 
            {
              ArrayList RESULT = null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		ArrayList param = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							param.add(exp);
							RESULT = param;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(50/*paramLlamada*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // restoAsign ::= 
            {
              AnalisisAsignacion RESULT = null;
		
							RESULT=new AnalisisAsignacion(AnalisisAsignacion.LLAMADA, new ArrayList());
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(35/*restoAsign*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // restoAsign ::= NT$10 sPARAPER paramLlamada sPARCIE 
            {
              AnalisisAsignacion RESULT = null;
              // propagate RESULT from NT$10
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value != null )
                RESULT = (AnalisisAsignacion) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ArrayList param = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
							RESULT=new AnalisisAsignacion(AnalisisAsignacion.LLAMADA, param);
							this.queAnalizo=-1;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(35/*restoAsign*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // NT$10 ::= 
            {
              Object RESULT = null;

				  			this.queAnalizo = LLAMADA;
				  			// System.out.println("queAnalizo: "+ this.queAnalizo);
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(65/*NT$10*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // restoAsign ::= restoNombre sASIGNACION expresion 
            {
              AnalisisAsignacion RESULT = null;
		int resleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int resright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisSelector res = (AnalisisSelector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							// restonombre puede ser vacío, un array o un campo
							// Se realiza la expresión y se genera la asignación quedando pendiente comprobar el tipo asignado
							RESULT=new AnalisisAsignacion(AnalisisAsignacion.ASIGNACION,res,exp.getTipo());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(35/*restoAsign*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // asignLlamada ::= pID restoAsign 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int asignleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int asignright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisAsignacion asign = (AnalisisAsignacion)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (asign.getTipo() == AnalisisAsignacion.ASIGNACION){
								/* Se trata de una asignación */
								try{
									// Si se añaden la funciones también se puede tratar del identificador de una función
									ObjetoVariable objeto = (ObjetoVariable) this.tabla.buscarGlobal(id.toLowerCase());
									if (objeto == null){
										throw new ErrorSemanticoException("La variable \""+
							            	id +"\" no ha sido declarada (Línea: " + idleft +
							               	" columna " + idright + ")");
									}
									else{
										/* Comprobar tipos */;
										AnalisisSelector selector = asign.getSelector();
										if (selector==null){
											// Se trata de una variable normal{
											// Tenemos en la cima de la pila la expresión asignada => Comprobar tipos y asignar
											try{
//												ObjetoTipoPredefinido tipo = (ObjetoTipoPredefinido) objeto.getTipo();
												ObjetoTipo tipo = (ObjetoTipo) objeto.getTipo();
												// Comprobación de tipos se pueden asignar:
												//	* Valores enteros a variables de tipo INTEGER y REAL
												//  * Valores reales a variables de tipo REAL
												//  * Valores lógicos a variables lógicas // **** A reales y enteros decido que no????
												switch(this.tabla.compruebaTipo(asign.getTipoExp())){
													case TablaSimbolos.ENTERA:
														if (tipo==this.tabla.getInteger()){
														  // *** Generar la asignación entera
														  this.generaCargaDir(objeto);
														  this.generador.gAIndValor(JMPascalVM.TAMENTERO);
														}
														else if (tipo==this.tabla.getReal()){
																 this.generador.gAReal(0);
																 this.generaCargaDir(objeto);
																 this.generador.gAIndValor(JMPascalVM.TAMREAL);
															 }
															  else
																 throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																		id + " (Línea: "+ idleft + " Columna: " + idright + ")");
														break;
													case TablaSimbolos.REAL:
														if (tipo== this.tabla.getReal()){
															// *** Generar asignación real
															this.generaCargaDir(objeto);
															this.generador.gAIndValor(JMPascalVM.TAMREAL);
														}
														else
															throw new ErrorSemanticoException("No coinciden los tipos en la asignación de " +
																id + " (Línea: "+ idleft + " Columna: " + idright + ")");
														break;
													case TablaSimbolos.LOGICA:
														if (tipo== this.tabla.getBoolean()){
															/**** Si al final los lógicos son reales hay que cambiarlo ****/
															this.generaCargaDir(objeto);
															this.generador.gAIndValor(JMPascalVM.TAMLOGICA); 
														}
														else
															throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																id + " (Línea: "+ idleft + " Columna: " + idright + ")");
														break;
													case TablaSimbolos.NOPRIMITVO:
//****INICIO DEL CAMBIO PARA VER QUE SE PUEDEN ASIGNACIONES  DE NO PRIMITIVOS
//														//System.out.println("TIPO NO PRIMITIVO");
														this.generaCargaDir(objeto);
														this.generador.gAIndValor(asign.getTipo().getSize()); 
//****FIN DEL CAMBIO PARA VER QUE SE PUEDEN ASIGNACIONES  DE NO PRIMITIVOS
													    break;
										/*			default:
														throw new NoImplementadoException("El tipo de " +
															id + " no está implementado para ser asignado (Línea: "+
															idleft + " Columna: " + idright + ")"); */
												}
											}catch(ClassCastException e){
												throw new ErrorSemanticoException("El identificador " +
													id + " no es de un tipo válido (Línea: "+
													idleft + " Columna: " + idright + ")");
											}
										} // selector == null
										else{
											switch(selector.getTipo()){
												case AnalisisSelector.ARRAY:
													try{
														ObjetoTipoTabla tipo = (ObjetoTipoTabla) objeto.getTipo();
														// Tenemos en la cima de la pila la expresion a asignar (valor)
														// Posteriormente está el valor del índice
														// Se puede generar primero la asignación y el intérprete debe guardar el valor asignado para luego poder hacer el control de limitación
														// Se puede generar primero la limitación con lo que el intérprete debe sacar dos elementos de la pila
														// Me parece mejor lo primero
///************************

														switch(this.tabla.compruebaTipo(asign.getTipoExp())){
															case TablaSimbolos.ENTERA:
																if (tipo.getTipo()== this.tabla.getInteger()){
																  // *** Generar la asignación entera
																  this.generador.gLimitacion(tipo.getInicio(), tipo.getFin(),JMPascalVM.TAMENTERO);
																  this.generaCargaDirArray(objeto);
																  this.generador.gAIndValor(JMPascalVM.TAMENTERO);
																}
																else  if (tipo.getTipo()==this.tabla.getReal()){
																		 // *** Generar asignación real con redondeo
																		 this.generador.gAReal(0);
																		 this.generador.gLimitacion(tipo.getInicio(), tipo.getFin(),JMPascalVM.TAMREAL);
																  		 this.generaCargaDirArray(objeto);
																		 this.generador.gAIndValor(JMPascalVM.TAMREAL);
																	  }
																	  else
																		 throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																				id + " (Línea: "+ idleft + " Columna: " + idright + ")");
																break;
															case TablaSimbolos.REAL:
																if (tipo.getTipo()== this.tabla.getReal()){
																	// *** Generar asignación real
																	this.generador.gLimitacion(tipo.getInicio(), tipo.getFin(),JMPascalVM.TAMREAL);
																	this.generaCargaDirArray(objeto);
																	this.generador.gAIndValor(JMPascalVM.TAMREAL);
																}
																else
																	throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																		id + " (Línea: "+ idleft + " Columna: " + idright + ")");
																break;
															case TablaSimbolos.LOGICA:
																if (tipo.getTipo()== this.tabla.getBoolean()/* tipoLogico */){
																	this.generador.gLimitacion(tipo.getInicio(), tipo.getFin(),JMPascalVM.TAMLOGICA);
																	this.generaCargaDirArray(objeto);
																	this.generador.gAIndValor(JMPascalVM.TAMLOGICA); /**** si al final los logicos son reales debe cambiar ***/
																}
																else
																	throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																		id + " (Línea: "+ idleft + " Columna: " + idright + ")");
																break;
															case TablaSimbolos.NOPRIMITVO:
//																System.out.println("TIPO NO PRIMITIVO");
													    		break;
															
														}
//**** Yo dir´ria que esta asignación sobra														this.generador.gAIndValor(JMPascalVM.TAMLOGICA); // Depende del tipo se pondrá de una manera u otra
													}catch(ClassCastException e){
														throw new ErrorSemanticoException("El identificador " +
															id + " no es de un tipo tabla (Línea: "+
															idleft + " Columna: " + idright + ")");
													}
													break;
												case AnalisisSelector.RECORD:
													try{
														// Hay que obtener el tipo no de la variable si no del campo
														ObjetoTipoRegistro tipo = (ObjetoTipoRegistro) objeto.getTipo();
														ObjetoCampo campo = tipo.getCampo(selector.getSelector());
														ObjetoTipoPredefinido tipoCampo = (ObjetoTipoPredefinido) campo.getTipo();
														

														switch(this.tabla.compruebaTipo(asign.getTipoExp())){
															case TablaSimbolos.ENTERA:
																if (tipoCampo==this.tabla.getInteger()){
																  // *** Generar la asignación entera
																  this.generaCargaDirRegistro(objeto, campo);
																  this.generador.gAIndValor(JMPascalVM.TAMENTERO);
																}
																else  if (tipoCampo==this.tabla.getReal()){
																		 this.generador.gAReal(0);
																		 this.generaCargaDirRegistro(objeto, campo);
																		 this.generador.gAIndValor(JMPascalVM.TAMREAL);
																	  }
																	  else
																		 throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																				id + " (Línea: "+ idleft + " Columna: " + idright + ")");
																break;
															case TablaSimbolos.REAL:
																if (tipoCampo==this.tabla.getReal()){
																	// *** Generar asignación real
																	this.generaCargaDirRegistro(objeto, campo);
																	this.generador.gAIndValor(JMPascalVM.TAMREAL);
																}
																else
																	throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																		id + " (Línea: "+ idleft + " Columna: " + idright + ")");
																break;
															case TablaSimbolos.LOGICA:
																if (tipoCampo== this.tabla.getBoolean()){
																	this.generaCargaDirRegistro(objeto, campo);
																	this.generador.gAIndValor(JMPascalVM.TAMLOGICA); /**** si al final los logicos son reales debe cambiar ***/
																}
																else
																	throw new ErrorSemanticoException("No coinciden los tipos en la asgnación de " +
																		id + " (Línea: "+ idleft + " Columna: " + idright + ")");
																break;
															case TablaSimbolos.NOPRIMITVO:
//																System.out.println("TIPO NO PRIMITIVO");
															    break;

														}
													}catch(ClassCastException e){
														throw new ErrorSemanticoException("El identificador " +
															id + " no es de un tipo registro (Línea: "+
															idleft + " Columna: " + idright + ")");
													}
													break;
											}
										}
									}
									
								}catch(ClassCastException e){
									throw new ErrorSemanticoException("El identificador \""+
							               id +"\" no ha sido declarado como variable (Línea: " +
							               idleft + " columna " + idright + ")");
								}
							}
							else{
								/* Se trata de una llamada */
								// System.out.println("Se trata de una llamada");
								try{
								   ObjetoProcPredefinido objeto = (ObjetoProcPredefinido) this.tabla.buscarGlobal(id.toLowerCase());
								   if (objeto == null)
									   throw new ErrorSemanticoException("El subprograma \""+
						            	   id +"\" no ha sido declarado (Línea: " + idleft +
						               	   " columna " + idright + ")");
								   ArrayList parametros = asign.getParametros();
								   if (parametros.size() != 1)
									  throw new ErrorSemanticoException("Error en el número de parámetros "
						            	  + " (Línea: " + idleft + " columna " + idright + ")");
								   try{
								   	  AnalisisExp pasado = (AnalisisExp) parametros.get(0);
						              ObjetoTipoPredefinido tipo = (ObjetoTipoPredefinido) pasado.getTipo();
									  ArrayList cola = pasado.getCola();
								      if (objeto == this.tabla.getWrite()){
										 for(int j=0; j<cola.size();j++){
											ArrayList instruccion = (ArrayList) cola.get(j);
											this.generador.anyadeCodigo((String) instruccion.get(1));
										 }
								         if (tipo==this.tabla.getBoolean() || tipo==this.tabla.getInteger())
								            this.generador.gGrabacion();
								         else
								            if (tipo==this.tabla.getReal())
								               this.generador.gGrabacionReal();
								            else if (tipo==this.tabla.getString())
								                    this.generador.gGrabacionLiteral();
								      }
								      else{
										 if (!pasado.getEsVariable())
										    throw new ErrorSemanticoException("El procedimiento predefinido read no admite expresiones como parámetros "
						            	       + " (Línea: " + idleft + " columna " + idright + ")");
										 for(int j=0; j<cola.size();j++){
											ArrayList instruccion = (ArrayList) cola.get(j);
											if (((Boolean)instruccion.get(0)).booleanValue())
											   this.generador.anyadeCodigo((String) instruccion.get(1));
										 }
								         if (tipo==this.tabla.getBoolean() || tipo==this.tabla.getInteger())
								            this.generador.gLectura();
								         else
								            if (tipo==this.tabla.getReal())
								               this.generador.gLecturaReal();
								      }
								   }catch(ClassCastException ex){
									  throw new ErrorSemanticoException("Los procedimineto predefinidos " + 
									      "write y read sólo admiten "+
									      "parametros de tipos primitivos (Línea: " + idleft +
						               	  " columna " + idright + ")");
						           }
								}catch(ClassCastException e){
									try{
										// Si se añaden la funciones también se puede tratar del identificador de una función
										ObjetoProc objeto = (ObjetoProc) this.tabla.buscarGlobal(id.toLowerCase());
										if (objeto == null){
											throw new ErrorSemanticoException("El subprograma \""+
								            	id +"\" no ha sido declarado (Línea: " + idleft +
								               	" columna " + idright + ")");
										}
										else{
											// Lo primero hay que recorrer el arrayList param de asign para comprobar que los tipos corresponden y que las referencias son válidas
											ArrayList parametros = asign.getParametros();
											ArrayList listaParametros = objeto.getParametros();
											if (parametros.size() != listaParametros.size()){
												throw new ErrorSemanticoException("Error en el número de parámetros "
								            		+ " (Línea: " + idleft + " columna " + idright + ")");
											}
											for (int i=0;i<parametros.size();i++){
												ObjetoParametro original = (ObjetoParametro) listaParametros.get(i);
												AnalisisExp pasado = (AnalisisExp) parametros.get(i);
												ArrayList cola = pasado.getCola();
												// System.out.println("La cola es: " + cola.toString());
												if (original.isReferencia()){
													// Se comprueba que el parámetro es un identificador de variable (puede ser un campo o simplemente un elemento de un array)
													// Se copia la dirección en la pila ¿dónde? => Posiblemente ya está copiada
													if (pasado.getEsVariable()){
														if (pasado.getTipo() == original.getTipo()){
															//Se escriben en el generador todo lo necesario de la cola de instrucciones
															for(int j=0; j<cola.size();j++){
															    ArrayList instruccion = (ArrayList) cola.get(j);
	//														    this.generador.anyadeCodigo((String) instruccion.get(1));
																if (((Boolean)instruccion.get(0)).booleanValue())
																	this.generador.anyadeCodigo((String) instruccion.get(1));
															}
														}
														else{
															throw new ErrorSemanticoException("No coincide los tipos de los parámetros "
											            		+ " (Línea: " + idleft + " columna " + idright + ")");
														}
													}
													else
														throw new ErrorSemanticoException("Los parámetros por referencia no pueden ser expresiones "
										            		+ " (Línea: " + idleft + " columna " + idright + ")");
												}
												else{
													// Se comprueba el tipo
													// se copia el valor de la expresión el la pila :
													//		* Caso 1: Es una variable carga de valor => Seguramente ya está cargado
													//		* Caso 2: Es una expresión => Ya está cargada ¿dónde?
														if (pasado.getTipo() == original.getTipo()){
															//Se escriben en el generador todo lo necesario de la cola de instrucciones
															for(int j=0; j<cola.size();j++){
															   ArrayList instruccion = (ArrayList) cola.get(j);
															   this.generador.anyadeCodigo((String) instruccion.get(1));
															}
														}
														else{
															throw new ErrorSemanticoException("No coincide los tipos de los parámetros "
											            		+ " (Línea: " + idleft + " columna " + idright + ")");
														}
												}
											}	
											if (objeto.getNivAnidamiento() > 0)
											   this.generador.gCDirLocal(0); // EE
											this.generador.gLlamada(objeto.getNumSubpr());
										}
									}catch(ClassCastException ex){
										// Además podrían ser funciones
										throw new ErrorSemanticoException("El identificador \""+
							            	id +"\" no ha sido declarado como subprograma (Línea: " + idleft +
							               	" columna " + idright + ")");
							        }
								}
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(1/*asignLlamada*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // restoIF ::= 
            {
              Object RESULT = null;
		
				  			this.generador.gEtqCondicional(this.tabla.getNumIncondicionalActual());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(25/*restoIF*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // restoIF ::= prELSE sentencia 
            {
              Object RESULT = null;
		
				  			this.generador.gEtqCondicional(this.tabla.getNumIncondicionalActual());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(25/*restoIF*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // condicional ::= prIF expresion prTHEN NT$8 sentencia NT$9 restoIF 
            {
              Object RESULT = null;
              // propagate RESULT from NT$8
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
              // propagate RESULT from NT$9
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;

              CUP$Parser$result = new java_cup.runtime.Symbol(7/*condicional*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // NT$9 ::= 
            {
              Object RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;

							this.generador.gBifIncond(this.tabla.actualizaNumIncondicional());
				  			this.generador.gEtqCondicional(this.tabla.getNumCondicionalActual());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(64/*NT$9*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // NT$8 ::= 
            {
              Object RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		AnalisisExp exp = (AnalisisExp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

							this.generador.gBifCond(this.tabla.actualizaNumCondicional());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(63/*NT$8*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentencia ::= 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(21/*sentencia*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sentencia ::= grupoSent 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(21/*sentencia*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sentencia ::= bucle 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(21/*sentencia*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentencia ::= asignLlamada 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(21/*sentencia*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // sentencia ::= condicional 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(21/*sentencia*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sentencias ::= sentencia 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(22/*sentencias*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentencias ::= sentencias sPUNTOCOMA sentencia 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(22/*sentencias*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // grupoSent ::= prBEGIN sentencias prEND 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(18/*grupoSent*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // listaID ::= pID 
            {
              ArrayList RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (this.tabla.getPrograma().getNombre().equals(id.toLowerCase()))
								throw new ErrorSemanticoException("No se puede redefinir" +
										" el nombre del programa (Línea: " +
										idleft + " columna " + idright + ")");
							else
								if (this.tabla.buscarLocal(id.toLowerCase())!=null)
									throw new ErrorSemanticoException("Identificador \""+
							               id +"\" repetido en línea: " + idleft +
							               " columna " + idright);
								else{
								   // this.log.anadirLog("\nAñado por la final");
								   RESULT = new ArrayList();
						  		   RESULT.add(id.toLowerCase());
						  		}
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(44/*listaID*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // listaID ::= listaID sCOMA pID 
            {
              ArrayList RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
			
							if (this.tabla.getPrograma().getNombre().equals(id.toLowerCase()))
								throw new ErrorSemanticoException("No se puede redefinir" +
										" el nombre del programa (Línea: " +
										idleft + " columna " + idright + ")");
							else
								if (lista.contains(id.toLowerCase()) || this.tabla.buscarLocal(id.toLowerCase())!=null){
									throw new ErrorSemanticoException("Identificador \""+
											id +"\" repetido en línea: " + idleft +
											" columna " + idright);
								}
								else{
									// this.log.anadirLog("\nAñado por recursividad");
									lista.add(id.toLowerCase());
									RESULT = lista;
								}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(44/*listaID*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // listaVar ::= listaID sDOSPUNTOS pID 
            {
              ArrayList RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int elTipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int elTiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String elTipo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
			
							ObjetoTipo tipo = null;
							try{
						   		tipo = (ObjetoTipo) this.tabla.buscarGlobal(elTipo.toLowerCase());
								if (tipo != null)
									switch (this.queAnalizo){
										case REGISTRO:
										case PARAMETROS:
											RESULT = new ArrayList(2);
											RESULT.add(0,tipo);
											RESULT.add(1,lista);
											break;
										case VARIABLES:
											for(int i=0;i<lista.size();i++){
												/***** Comprobar que en la lista vienen con LowerCase ****/
										   		if (this.tabla.getActivo() == this.tabla.getGlobal()){
										   		   this.tabla.insertar((String)lista.get(i),new ObjetoVariable((String)lista.get(i), tipo,this.tabla.getDireccion(),this.tabla.getActivo()));
												   this.tabla.setDireccion(this.tabla.getDireccion()+tipo.getSize());
											       this.tabla.setTamEspacio(this.tabla.getTamEspacio()+tipo.getSize());
											    }
												else{
										   		   this.tabla.insertar((String)lista.get(i),new ObjetoVariable((String)lista.get(i), tipo,this.tabla.getDireccion()-tipo.getSize()+1,this.tabla.getActivo()));
												   this.tabla.setDireccion(this.tabla.getDireccion()-tipo.getSize());
											       this.tabla.setTamEspacioLocal(this.tabla.getTamEspacioLocal()+tipo.getSize());
												}
										   	}
									}
								else
									throw new ErrorSemanticoException("El tipo " + 
										elTipo + " no está declarado (Línea: " +
										elTipoleft + " columna: " + elTiporight + ")");
							}catch (ClassCastException e){
					    		throw new ErrorSemanticoException(elTipo +
					    			" no es un tipo declarado (Línea: " + 
					    			elTipoleft + " Columna: " + elTiporight + ")");
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(46/*listaVar*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // listaParam ::= listaVar 
            {
              ArrayList RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							lista.add(2,new Boolean(false));
							RESULT = lista;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(48/*listaParam*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // listaParam ::= prVAR listaVar 
            {
              ArrayList RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							lista.add(2,new Boolean(true));
				  			RESULT = lista;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(48/*listaParam*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // listasParam ::= listaParam 
            {
              ArrayList RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT = new ArrayList();
				  			RESULT.add(lista);
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(49/*listasParam*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // listasParam ::= listasParam sPUNTOCOMA listaParam 
            {
              ArrayList RESULT = null;
		int totalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int totalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		ArrayList total = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							total.add(lista);
							RESULT = total;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(49/*listasParam*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // parametros ::= 
            {
              ArrayList RESULT = null;
		
				  			RESULT = null;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(47/*parametros*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // parametros ::= NT$7 sPARAPER listasParam sPARCIE 
            {
              ArrayList RESULT = null;
              // propagate RESULT from NT$7
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value != null )
                RESULT = (ArrayList) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
							// ObjetoTipoRegistro registro = new ObjetoTipoRegistro();
							RESULT = new ArrayList();
							int contador = 0;
							for (int i=0; i<lista.size();i++){
								ArrayList listaParametros = (ArrayList) lista.get(i);
								/**** Comprobar si sería bueno incluir constantes para diferenciar tipo e ID's ****/
								ObjetoTipo tipo = (ObjetoTipo)listaParametros.get(0);
								ArrayList listaID = (ArrayList) listaParametros.get(1);
								Boolean referencia = (Boolean) listaParametros.get(2);
								for (int j=0; j<listaID.size(); j++)
							       if (referencia.booleanValue())
									   contador+=JMPascalVM.TAMDIR;
								   else
									   contador+=tipo.getSize();
							}
							
							if (this.tabla.getNivAnidamiento() > 1){
								this.tabla.setTamEspacio(JMPascalVM.TAMDIR + contador); // Se añade el Enlace Estático
								contador+=(JMPascalVM.TAMDIR * 3); // Enlace Dinámico, Dirección de Retorno y Enlace Estático
							}
							else{
								this.tabla.setTamEspacio(contador);								
								contador+=(JMPascalVM.TAMDIR * 2); // Enlace Dinámico y Dirección de Retorno
							}
							this.tabla.setDireccion(contador);
							for (int i=0; i<lista.size(); i++){
								ArrayList listaParametros = (ArrayList) lista.get(i);
								/**** Comprobar si sería bueno incluir constantes para diferenciar tipo e ID's ****/
								ObjetoTipo tipo = (ObjetoTipo)listaParametros.get(0);
								ArrayList listaID = (ArrayList) listaParametros.get(1);
								Boolean referencia = (Boolean) listaParametros.get(2);
								for (int j=0; j<listaID.size(); j++){
									Objeto parametro = null;
									if (referencia.booleanValue()){
									    parametro = new ObjetoParametro((String) listaID.get(j), tipo,this.tabla.getDireccion()-JMPascalVM.TAMDIR,referencia.booleanValue(),this.tabla.getActivo());
										this.tabla.setDireccion(this.tabla.getDireccion()-JMPascalVM.TAMDIR);
									}
									else{
									    parametro = new ObjetoParametro((String) listaID.get(j), tipo,this.tabla.getDireccion()-tipo.getSize(),referencia.booleanValue(),this.tabla.getActivo());
										this.tabla.setDireccion(this.tabla.getDireccion()-tipo.getSize());
									}
//									this.tabla.setDireccion(this.tabla.getDireccion()+tipo.getSize());
									/***** Comprobar que en la lista vienen con LowerCase ****/
									this.tabla.insertar((String) listaID.get(j), parametro);
									RESULT.add(parametro);
								}
							}
							this.tabla.setDireccion(JMPascalVM.TAMDIR * -1); // En la dirección 0 siempre está el enlace dinámico
						
              CUP$Parser$result = new java_cup.runtime.Symbol(47/*parametros*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // NT$7 ::= 
            {
              Object RESULT = null;

							this.queAnalizo = PARAMETROS ;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(62/*NT$7*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // defProc ::= prPROCEDURE pID NT$5 parametros sPUNTOCOMA NT$6 bloque 
            {
              Object RESULT = null;
              // propagate RESULT from NT$5
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
              // propagate RESULT from NT$6
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		ArrayList param = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
							// Devolver la memoria
							this.generador.gDevolucion(this.tabla.getTamEspacio());
							this.tabla.setNivAnidamiento(this.tabla.getNivAnidamiento()-1);
							this.tabla.suprimirNivel();
						
              CUP$Parser$result = new java_cup.runtime.Symbol(13/*defProc*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // NT$6 ::= 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ArrayList param = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

							ObjetoProc proc = (ObjetoProc) this.tabla.buscarGlobal(id.toLowerCase());
							proc.setParametros(param);
						
              CUP$Parser$result = new java_cup.runtime.Symbol(61/*NT$6*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // NT$5 ::= 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;

							if (this.tabla.buscarLocal(id.toLowerCase())==null){
								ObjetoProc proc=new ObjetoProc(id, this.tabla.actualizaNumSubpr(), this.tabla.getNivAnidamiento());
								this.tabla.setNivAnidamiento(this.tabla.getNivAnidamiento() + 1);
								this.tabla.insertar(id.toLowerCase(),proc);
								this.tabla.creaNivel();
								RESULT=proc;
							}
							else
								throw new ErrorSemanticoException("El identificador: " + 
									id + " está duplicado (Línea: " + idleft +
									" Columna: " +  idright + ")");
						
              CUP$Parser$result = new java_cup.runtime.Symbol(60/*NT$5*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // defFuncion ::= prFUNCTION pID parametros sDOSPUNTOS pID sPUNTOCOMA NT$4 bloque 
            {
              Object RESULT = null;
              // propagate RESULT from NT$4
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		ArrayList param = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
							if (this.valorDevuelto)
								this.tabla.suprimirNivel();
//*****Luego poner en marcha								valorDevuelto = false;
							else
								throw new ErrorSemanticoException("La función "+
									id + " no devuelve ningún valor (Línea: "+
									idleft + " Columna: "+ idright + ")");
						
              CUP$Parser$result = new java_cup.runtime.Symbol(12/*defFuncion*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$4 ::= 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		ArrayList param = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

							if (this.tabla.buscarLocal(id.toLowerCase())==null){
								try{
									ObjetoTipo t = (ObjetoTipo) this.tabla.buscarGlobal(tipo);
									if (t!=null){
										//**** Faltan muchas cosas como control de que sea un tipo e inserción de número de subpr
										// this.tabla.insertar(id.toLowerCase(),new ObjetoFuncion(id, param, t));
										this.tabla.creaNivel();
									}
									else
										throw new ErrorSemanticoException("El tipo: " + 
											tipo + " no está declarado (Línea: " + tipoleft +
											" Columna: " +  tiporight + ")");
									
								}catch (ClassCastException e){
									throw new ErrorSemanticoException("El identificador "+
										tipo + " no es un tipo (Línea: "+
										tipoleft + " Columna: "  + tiporight +
										")");
								}
							}
							else
								throw new ErrorSemanticoException("El identificador: " + 
									id + " está duplicado (Línea: " + idleft +
									" Columna: " +  idright + ")");
						
              CUP$Parser$result = new java_cup.runtime.Symbol(59/*NT$4*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // defSubpr ::= 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(14/*defSubpr*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // defSubpr ::= defSubpr defProc sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(14/*defSubpr*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // defSubpr ::= defSubpr defFuncion sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(14/*defSubpr*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // listasVar ::= listaVar sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(19/*listasVar*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // listasVar ::= listasVar listaVar sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(19/*listasVar*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // defVar ::= 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(16/*defVar*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // defVar ::= NT$3 prVAR listasVar 
            {
              Object RESULT = null;
              // propagate RESULT from NT$3
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;

              CUP$Parser$result = new java_cup.runtime.Symbol(16/*defVar*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$3 ::= 
            {
              Object RESULT = null;

							this.queAnalizo = VARIABLES ;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(58/*NT$3*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // listaCampos ::= listaVar 
            {
              ArrayList RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT = new ArrayList();
				  			RESULT.add(lista);
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(45/*listaCampos*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // listaCampos ::= listaCampos sPUNTOCOMA listaVar 
            {
              ArrayList RESULT = null;
		int totalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int totalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		ArrayList total = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							total.add(lista);
							RESULT = total;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(45/*listaCampos*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // tipoReg ::= NT$2 prRECORD listaCampos prEND 
            {
              ObjetoTipoRegistro RESULT = null;
              // propagate RESULT from NT$2
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value != null )
                RESULT = (ObjetoTipoRegistro) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
							ObjetoTipoRegistro registro = new ObjetoTipoRegistro();
							for (int i=0,direccion=0; i<lista.size(); i++){
								ArrayList listaVar = (ArrayList) lista.get(i);
								/**** Comprobar si sería bueno incluir constantes para diferenciar tipo e ID's ****/
								ObjetoTipo tipo = (ObjetoTipo)listaVar.get(0);
								ArrayList listaID = (ArrayList) listaVar.get(1);
								for (int j=0; j<listaID.size(); j++){
									/***** Comprobar que en la lista vienen con LowerCase ****/
									registro.insertaCampo(new ObjetoCampo((String) listaID.get(j), tipo,direccion,this.tabla.getActivo()));
									direccion+=tipo.getSize();
								}
							}
							RESULT = registro;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(53/*tipoReg*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$2 ::= 
            {
              Object RESULT = null;

							this.queAnalizo = REGISTRO ;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(57/*NT$2*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // defSubrango ::= pID 
            {
              String RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			ObjetoTipoEnumerado tipo = null;
							try{
								if ((tipo = (ObjetoTipoEnumerado) this.tabla.buscarGlobal(id.toLowerCase()))==null)
									throw new ErrorSemanticoException("El tipo enumerado "+
										id+" no ha sido definido (Línea: "+
										idleft + " Columna: "  + idright +
										")");
								else
									RESULT = new String("1:" + tipo.getTamanio());
							}catch (ClassCastException e){
									throw new ErrorSemanticoException("El identificador "+
										id+" no es un tipo enumerado (Línea: "+
										idleft + " Columna: "  + idright +
										")");
							} 
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(26/*defSubrango*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // defSubrango ::= exprSimpleCte sSUBRANGO exprSimpleCte 
            {
              String RESULT = null;
		int inicioleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int inicioright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExpCte inicio = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int finleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int finright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte fin = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (inicio.getTipoValor()!=AnalisisExpCte.ENTERA || fin.getTipoValor()!=AnalisisExpCte.ENTERA)
							   throw new ErrorSemanticoException("Los delimitadores de unsubrango deben ser valores"+
							   		" constantes enteros (Línea: " + sleft + 
							   		" Columna: " + sright + ")");
							else
								RESULT = new String(inicio.getValor() + ":" + fin.getValor());
						
              CUP$Parser$result = new java_cup.runtime.Symbol(26/*defSubrango*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // tipoTab ::= prARRAY sCORAPER defSubrango sCORCIE prOF pID 
            {
              ObjetoTipoTabla RESULT = null;
		int rangoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int rangoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String rango = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							ObjetoTipoPredefinido tipo = null;
							try{
								if ((tipo = (ObjetoTipoPredefinido) this.tabla.buscarGlobal(id.toLowerCase()))==null)
									throw new ErrorSemanticoException("El tipo "+
										id+" no ha sido definido (Línea: "+
										idleft + " Columna: "  + idright +
										")");
								else{
									int inicio = new Integer(rango.substring(0,rango.indexOf(':'))).intValue();
									int fin = new Integer(rango.substring(rango.indexOf(':')+1)).intValue();
									RESULT = new ObjetoTipoTabla(inicio, fin, tipo);
								}
							}catch (ClassCastException e){
									throw new ErrorSemanticoException("El identificador "+
										id+" no es un tipo (Línea: "+
										idleft + " Columna: "  + idright +
										")");
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(54/*tipoTab*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // tipoEnum ::= sPARAPER listaID sPARCIE 
            {
              ObjetoTipoEnumerado RESULT = null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		ArrayList lista = (ArrayList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
							RESULT = new ObjetoTipoEnumerado(lista);
							for(int i=0; i<lista.size(); i++){
							    /***** Comprobar que en la lista vienen con LowerCase ****/
								this.tabla.insertar((String) lista.get(i), new ObjetoEtiquetaEnumerado((String) lista.get(i),RESULT,i+1));
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(52/*tipoEnum*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // espTipo ::= tipoReg 
            {
              ObjetoTipo RESULT = null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ObjetoTipoRegistro tipo = (ObjetoTipoRegistro)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = tipo;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(51/*espTipo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // espTipo ::= tipoTab 
            {
              ObjetoTipo RESULT = null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ObjetoTipoTabla tipo = (ObjetoTipoTabla)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = tipo;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(51/*espTipo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // espTipo ::= tipoEnum 
            {
              ObjetoTipo RESULT = null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ObjetoTipoEnumerado tipo = (ObjetoTipoEnumerado)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = tipo;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(51/*espTipo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // tipo ::= pID sIGUAL espTipo 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		ObjetoTipo tipo = (ObjetoTipo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			if (this.tabla.buscarLocal(id.toLowerCase())==null){
				  				tipo.setNombre(id.toLowerCase());
				  				this.tabla.insertar(id.toLowerCase(), tipo);
				  			}
				  			else
				  				throw new ErrorSemanticoException("El identificador del tipo está duplicado (Línea: "+ idleft +" Columna: " +idright + ")");
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(23/*tipo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // tipos ::= tipo sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(24/*tipos*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // tipos ::= tipos tipo sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(24/*tipos*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // defTipo ::= 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(15/*defTipo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // defTipo ::= prTYPE tipos 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(15/*defTipo*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // factorCte ::= sPARAPER expresionCte sPARCIE 
            {
              AnalisisExpCte RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
				  			RESULT = exp;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(40/*factorCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // factorCte ::= prNOT factorCte 
            {
              AnalisisExpCte RESULT = null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte f = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			if (f.getValor().equals("true"))
				  				f.setValor("false");
				  			else
				  				f.setValor("true");
				  			RESULT = f;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(40/*factorCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // factorCte ::= pID 
            {
              AnalisisExpCte RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			ObjetoCte constante = null;
				  			try{
				  				if ((constante=(ObjetoCte)this.tabla.buscarGlobal(id.toLowerCase()))==null)
				  					throw new ErrorSemanticoException("El identificador " +
				  						id + " no está declarado (Línea: "+
				  						idleft + " Columna: " + idright + ")");
				  				else{
				  				    try{
			  						   ObjetoCteEntera constanteTip = (ObjetoCteEntera) constante ;
			  						   RESULT = new AnalisisExpCte(AnalisisExpCte.ENTERA,String.valueOf(constanteTip.getValor()));
									}catch(ClassCastException e1){
									   try{
					  						ObjetoCteReal constanteTip = (ObjetoCteReal) constante ;
					  						RESULT = new AnalisisExpCte(AnalisisExpCte.REAL,String.valueOf(constanteTip.getValor()));
										}catch(ClassCastException e2){
										    try{
						  						ObjetoCteLogica constanteTip = (ObjetoCteLogica) constante ;
						  						RESULT = new AnalisisExpCte(AnalisisExpCte.LOGICA,String.valueOf(constanteTip.getValor()));
											}catch(ClassCastException e3){
											    try{
							  					   ObjetoCteLiteral constanteTip = (ObjetoCteLiteral) constante ;
							  					   RESULT = new AnalisisExpCte(AnalisisExpCte.LITERAL,String.valueOf(constanteTip.getValor()));
												}catch(Exception e4){
				  									throw new ErrorSemanticoException("La constante " +
				  										id + " no es de un tipo válido (Línea: "+
				  										idleft + " Columna: " + idright + ")");
												}
											}
										}
									}
								}
				  			}catch(ClassCastException e){
				  				throw new ErrorSemanticoException ("El identificador "+
				  						"no se corresponde con una constante (Línea: "+
				  						idleft + " Columna: " + idright + ")");
				  			}
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(40/*factorCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // factorCte ::= pCteReal 
            {
              AnalisisExpCte RESULT = null;
		int cteleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int cteright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		Float cte = (Float)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = new AnalisisExpCte(AnalisisExpCte.REAL,String.valueOf((float)cte.floatValue()));
						
              CUP$Parser$result = new java_cup.runtime.Symbol(40/*factorCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // factorCte ::= pCteEntera 
            {
              AnalisisExpCte RESULT = null;
		int cteleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int cteright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		Integer cte = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = new AnalisisExpCte(AnalisisExpCte.ENTERA,String.valueOf(cte.intValue()));
						
              CUP$Parser$result = new java_cup.runtime.Symbol(40/*factorCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // terminoCte ::= factorCte 
            {
              AnalisisExpCte RESULT = null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte f = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT = f;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(41/*terminoCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // terminoCte ::= terminoCte opMult factorCte 
            {
              AnalisisExpCte RESULT = null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExpCte exp1 = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character op = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp2 = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
								switch(op.charValue()){
									case '*':
										if ((exp1.getTipoValor()!=AnalisisExpCte.ENTERA && exp1.getTipoValor()!=AnalisisExpCte.REAL) || (exp2.getTipoValor()!=AnalisisExpCte.ENTERA && exp2.getTipoValor()!=AnalisisExpCte.REAL))
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
															opleft + " Columna: " +
															opright + ")");
										else
											if (exp1.getTipoValor()==AnalisisExpCte.REAL || exp2.getTipoValor()==AnalisisExpCte.REAL){
												exp1.setTipoValor(AnalisisExpCte.REAL);
												exp1.setValor(String.valueOf(new Float(exp1.getValor()).floatValue() * (new Float(exp2.getValor()).floatValue())));
											}
											else
												exp1.setValor(String.valueOf(new Integer(exp1.getValor()).intValue() * (new Integer(exp2.getValor()).intValue())));
										break;
									case '/':
										if ((exp1.getTipoValor()!=AnalisisExpCte.ENTERA && exp1.getTipoValor()!=AnalisisExpCte.REAL) || (exp2.getTipoValor()!=AnalisisExpCte.ENTERA && exp2.getTipoValor()!=AnalisisExpCte.REAL))
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
															opleft + " Columna: " +
															opright + ")");
										else
											if (exp1.getTipoValor()==AnalisisExpCte.REAL || exp2.getTipoValor()==AnalisisExpCte.REAL){
												exp1.setTipoValor(AnalisisExpCte.REAL);
												exp1.setValor(String.valueOf(new Float(exp1.getValor()).floatValue() / (new Float(exp2.getValor()).floatValue())));
											}
											else
												exp1.setValor(String.valueOf(new Integer(exp1.getValor()).intValue() / (new Integer(exp2.getValor()).intValue())));
										break;
									case '%':
										if ((exp1.getTipoValor()!=AnalisisExpCte.ENTERA && exp1.getTipoValor()!=AnalisisExpCte.REAL) || (exp2.getTipoValor()!=AnalisisExpCte.ENTERA && exp2.getTipoValor()!=AnalisisExpCte.REAL))
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
															opleft + " Columna: " +
															opright + ")");
										else
											if (exp1.getTipoValor()==AnalisisExpCte.REAL || exp2.getTipoValor()==AnalisisExpCte.REAL){
												exp1.setTipoValor(AnalisisExpCte.REAL);
												exp1.setValor(String.valueOf(new Float(exp1.getValor()).floatValue() % (new Float(exp2.getValor()).floatValue())));
											}
											else
												exp1.setValor(String.valueOf(new Integer(exp1.getValor()).intValue() % (new Integer(exp2.getValor()).intValue())));
										break;
									case '&':
										if (exp1.getTipoValor()!=AnalisisExpCte.LOGICA || exp2.getTipoValor()!=AnalisisExpCte.LOGICA)
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
															opleft + " Columna: " +
															opright + ")");
										else
											exp1.setValor(String.valueOf(new Boolean(exp1.getValor()).booleanValue() && new Boolean(exp2.getValor()).booleanValue()));
										break;
								}
								RESULT = exp1;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(41/*terminoCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // exprSimpleCte ::= terminoCte 
            {
              AnalisisExpCte RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = exp;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(39/*exprSimpleCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // exprSimpleCte ::= signo terminoCte 
            {
              AnalisisExpCte RESULT = null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character s = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			if (s!=null)
								switch (exp.getTipoValor()){
									case AnalisisExpCte.ENTERA:
										exp.setValor(String.valueOf(new Integer(exp.getValor()).intValue() * -1));	
										break;
									case AnalisisExpCte.REAL:
										exp.setValor(String.valueOf(new Float(exp.getValor()).floatValue() * -1.0));	
										break;
								}
							RESULT = exp;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(39/*exprSimpleCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // exprSimpleCte ::= exprSimpleCte opAdt terminoCte 
            {
              AnalisisExpCte RESULT = null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExpCte exp1 = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character op = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp2 = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
								int factor = 1;
								switch(op.charValue()){
									case '-':
										factor = -1;
									case '+':
										if ((exp1.getTipoValor()!=AnalisisExpCte.ENTERA && exp1.getTipoValor()!=AnalisisExpCte.REAL) || (exp2.getTipoValor()!=AnalisisExpCte.ENTERA && exp2.getTipoValor()!=AnalisisExpCte.REAL))
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
															opleft + " Columna: " +
															opright + ")");
										else
											if (exp1.getTipoValor()==AnalisisExpCte.REAL || exp2.getTipoValor()==AnalisisExpCte.REAL){
												exp1.setTipoValor(AnalisisExpCte.REAL);
												exp1.setValor(String.valueOf(new Float(exp1.getValor()).floatValue() + (factor * new Float(exp2.getValor()).floatValue())));
											}
											else
												exp1.setValor(String.valueOf(new Integer(exp1.getValor()).intValue() + (factor * new Integer(exp2.getValor()).intValue())));
										break;
									case '|':
										if (exp1.getTipoValor()!=AnalisisExpCte.LOGICA || exp2.getTipoValor()!=AnalisisExpCte.LOGICA)
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
															opleft + " Columna: " +
															opright + ")");
										else
											exp1.setValor(String.valueOf(new Boolean(exp1.getValor()).booleanValue() || new Boolean(exp2.getValor()).booleanValue()));
										break;
								}
								RESULT = exp1;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(39/*exprSimpleCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // expresionCte ::= exprSimpleCte 
            {
              AnalisisExpCte RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
				  			RESULT = exp;
				  		
              CUP$Parser$result = new java_cup.runtime.Symbol(38/*expresionCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // expresionCte ::= expresionCte opRel exprSimpleCte 
            {
              AnalisisExpCte RESULT = null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		AnalisisExpCte exp1 = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Character op = (Character)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp2 = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							// Se tiene en cuenta que true > false
								float expr1, expr2 ; 
								
								if (exp1.getTipoValor() != exp2.getTipoValor())
									if (exp1.getTipoValor() == AnalisisExpCte.LOGICA || exp2.getTipoValor() == AnalisisExpCte.LOGICA)
											throw new ErrorSemanticoException ("Error de tipos en expresión (Línea: " +
												opleft + " Columna: " +
												opright + ")");
								if (exp1.getTipoValor() == AnalisisExpCte.LOGICA){
									if (new Boolean(exp1.getValor()).booleanValue())
										expr1 = (float) 1.0;
									else
										expr1 = (float) 0.0;
									if (new Boolean(exp2.getValor()).booleanValue())
										expr2 = (float) 1.0;
									else
										expr2 = (float) 0.0;
								}
								else{
									expr1 = (float) new Float(exp1.getValor()).floatValue();
									expr2 = (float) new Float(exp2.getValor()).floatValue();
								}
								exp1.setTipoValor(AnalisisExpCte.LOGICA);
								switch(op.charValue()){
									case '=':
										exp1.setValor(String.valueOf(expr1 == expr2));
										break;
									case '!':
										exp1.setValor(String.valueOf(expr1 != expr2));
										break;
									case '>':
										exp1.setValor(String.valueOf(expr1 > expr2));
										break;
									case '<':
										exp1.setValor(String.valueOf(expr1 < expr2));
										break;
									case 'M':
										exp1.setValor(String.valueOf(expr1 >= expr2));
										break;
									case 'm':
										exp1.setValor(String.valueOf(expr1 <= expr2));
										break;
								}
								RESULT = exp1;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(38/*expresionCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // expLiteral ::= pCADENA 
            {
              AnalisisExpCte RESULT = null;
		int cadenaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int cadenaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String cadena = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = new AnalisisExpCte(AnalisisExpCte.LITERAL,cadena);
						
              CUP$Parser$result = new java_cup.runtime.Symbol(37/*expLiteral*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // expCte ::= expresionCte 
            {
              AnalisisExpCte RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = exp;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(36/*expCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // expCte ::= expLiteral 
            {
              AnalisisExpCte RESULT = null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							RESULT = exp;
						
              CUP$Parser$result = new java_cup.runtime.Symbol(36/*expCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // constante ::= pID sIGUAL expCte 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		AnalisisExpCte exp = (AnalisisExpCte)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		
							if (this.tabla.buscarLocal(id.toLowerCase())==null){
								switch (exp.getTipoValor()){
									case AnalisisExpCte.ENTERA:
										this.tabla.insertar(id.toLowerCase(), new ObjetoCteEntera(id, new Integer(exp.getValor()).intValue()));
										break;
									case AnalisisExpCte.LOGICA:
										this.tabla.insertar(id.toLowerCase(), new ObjetoCteLogica(id, new Boolean(exp.getValor()).booleanValue()));
										break;
									case AnalisisExpCte.REAL:
										this.tabla.insertar(id.toLowerCase(), new ObjetoCteReal(id, new Float(exp.getValor()).floatValue()));
										break;
									case AnalisisExpCte.LITERAL:
										this.tabla.insertar(id.toLowerCase(), new ObjetoCteLiteral(id, exp.getValor(), this.tabla.actualizaNumCadena()));
										this.generador.gDefLiteral(exp.getValor());
										break;
								}
							}
							else{
								throw new ErrorSemanticoException("Identificador repetido: " +
									id + " (Línea: " + idleft + " Columna: " + idright + ")");
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(8/*constante*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // constantes ::= constante sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*constantes*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // constantes ::= constantes constante sPUNTOCOMA 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*constantes*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // defCte ::= 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(11/*defCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // defCte ::= prCONST constantes 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(11/*defCte*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaracion ::= defCte defTipo defVar defSubpr 
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(10/*declaracion*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // bloque ::= declaracion NT$1 grupoSent 
            {
              Object RESULT = null;
              // propagate RESULT from NT$1
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = new java_cup.runtime.Symbol(2/*bloque*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Object RESULT = null;

							this.generador.gEtqSubpr(this.tabla.getNumSubprActual());
							if (this.tabla.getActivo() == this.tabla.getGlobal()){
								this.generador.gTamGlobal(this.tabla.getTamEspacio());
								this.generador.gTamFuncion(0); // De momento no se contemplan las funciones
							}
							else{
								this.generador.gReservaEsp(this.tabla.getTamEspacioLocal());
							}
						
              CUP$Parser$result = new java_cup.runtime.Symbol(56/*NT$1*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= prPROGRAM pID NT$0 sPUNTOCOMA bloque sPUNTO 
            {
              Object RESULT = null;
              // propagate RESULT from NT$0
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		
							this.tabla.suprimirNivel();
							this.generador.termina();
						
              CUP$Parser$result = new java_cup.runtime.Symbol(20/*program*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;

							this.tabla.creaGlobal();
							this.tabla.insertaPredefinido("integer",new ObjetoTipoPredefinido("integer", "Valores enteros",JMPascalVM.TAMENTERO));
							this.tabla.insertaPredefinido("real",new ObjetoTipoPredefinido("real", "Valores reales",JMPascalVM.TAMREAL));
							this.tabla.insertaPredefinido("boolean",new ObjetoTipoPredefinido("boolean", "Valores lógicos",JMPascalVM.TAMLOGICA));
							this.tabla.insertaPredefinido("string",new ObjetoTipoPredefinido("string", "Cadena",JMPascalVM.TAMDIR));
							this.tabla.insertaPredefinido("true",new ObjetoCteLogica("true",true)); /**** En caso de que se cambie por reales hay que cambiarlo ***/
							this.tabla.insertaPredefinido("false",new ObjetoCteLogica("false",false)); /**** En caso de que se cambie por reales hay que cambiarlo ***/
							this.tabla.insertaPredefinido("maxint",new ObjetoCteEntera("maxint",65536)); 
							this.tabla.insertaPredefinido("read",new ObjetoProcPredefinido("read")); 
							this.tabla.insertaPredefinido("write",new ObjetoProcPredefinido("write")); 
							ObjetoPrograma programa = new ObjetoPrograma(id.toLowerCase(),this.tabla.actualizaNumSubpr());
							this.tabla.insertar(id.toLowerCase(),programa);
							this.tabla.setPrograma(programa);
						
              CUP$Parser$result = new java_cup.runtime.Symbol(55/*NT$0*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

